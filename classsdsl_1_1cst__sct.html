<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Succinct Data Structure Library (sdsl): sdsl::cst_sct&lt; Csa, Lcp, Bp_support &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Succinct Data Structure Library (sdsl)
   
   </div>
   <div id="projectbrief">A C++ template library for succinct data structures</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacesdsl.html">sdsl</a>      </li>
      <li class="navelem"><a class="el" href="classsdsl_1_1cst__sct.html">cst_sct</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">sdsl::cst_sct&lt; Csa, Lcp, Bp_support &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cst.html">Compressed Suffix Trees (CST)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.  
 <a href="classsdsl_1_1cst__sct.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cst__sct_8hpp_source.html">cst_sct.hpp</a>&gt;</code></p>

<p><a href="classsdsl_1_1cst__sct-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6bac2832f6421c6a0dc27ca976e8f15b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bac2832f6421c6a0dc27ca976e8f15b"></a>
typedef Csa::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="memitem:a0e4f80e5dcf1f9a52d61f4852ab32820"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e4f80e5dcf1f9a52d61f4852ab32820"></a>
typedef <br class="typebreak"/>
<a class="el" href="classsdsl_1_1cst__dfs__const__forward__iterator.html">cst_dfs_const_forward_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classsdsl_1_1cst__sct.html">cst_sct</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="memitem:aa08670686fed09f52059930e4bd0f1c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa08670686fed09f52059930e4bd0f1c5"></a>
typedef <a class="el" href="classsdsl_1_1cst__dfs__const__forward__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="memitem:a2ee6d3c50c340f41d2c8e67b1a39ca05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ee6d3c50c340f41d2c8e67b1a39ca05"></a>
typedef <br class="typebreak"/>
<a class="el" href="classsdsl_1_1cst__bottom__up__const__forward__iterator.html">cst_bottom_up_const_forward_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classsdsl_1_1cst__sct.html">cst_sct</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_bottom_up_iterator</b></td></tr>
<tr class="memitem:a1e095341b4b20a8627fc6901c8311a98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e095341b4b20a8627fc6901c8311a98"></a>
typedef <a class="el" href="classsdsl_1_1cst__bottom__up__const__forward__iterator.html">const_bottom_up_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bottom_up_iterator</b></td></tr>
<tr class="memitem:a20c701103f536ed29bf8e79d2302e3f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20c701103f536ed29bf8e79d2302e3f6"></a>
typedef const value_type&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="memitem:aea49ed5aa2404e186c33bf124a86665b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea49ed5aa2404e186c33bf124a86665b"></a>
typedef const_reference&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="memitem:a5ce60c80ccfa31fb57378c9ece1ea3d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ce60c80ccfa31fb57378c9ece1ea3d7"></a>
typedef const_reference *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="memitem:a50db6e9a37835745c7cef16903dc40d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50db6e9a37835745c7cef16903dc40d1"></a>
typedef const pointer&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="memitem:ad35e3c8d2489e48eb295a6f695701eab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad35e3c8d2489e48eb295a6f695701eab"></a>
typedef Csa::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="memitem:a28aefefe5719d571cf3c061484cd9bb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28aefefe5719d571cf3c061484cd9bb9"></a>
typedef size_type&#160;</td><td class="memItemRight" valign="bottom"><b>cst_size_type</b></td></tr>
<tr class="memitem:af74dbd217766b151c1e8b7492a1cd9fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af74dbd217766b151c1e8b7492a1cd9fc"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="memitem:a75a7c31f67b0aab624ed24766f3941cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75a7c31f67b0aab624ed24766f3941cd"></a>
typedef Csa&#160;</td><td class="memItemRight" valign="bottom"><b>csa_type</b></td></tr>
<tr class="memitem:a47347553e47f68e79cce2bbfc19b2394"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47347553e47f68e79cce2bbfc19b2394"></a>
typedef Lcp&#160;</td><td class="memItemRight" valign="bottom"><b>lcp_type</b></td></tr>
<tr class="memitem:a7f2d8778645fbcb225fc90a6435a344f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f2d8778645fbcb225fc90a6435a344f"></a>
typedef Bp_support&#160;</td><td class="memItemRight" valign="bottom"><b>bp_support_type</b></td></tr>
<tr class="memitem:a18d24fee56bb3dfa1a97b3bcd446f805"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18d24fee56bb3dfa1a97b3bcd446f805"></a>
typedef Csa::pattern_type&#160;</td><td class="memItemRight" valign="bottom"><b>pattern_type</b></td></tr>
<tr class="memitem:ab2a3449ad558ef059d7fea807c82f0e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2a3449ad558ef059d7fea807c82f0e4"></a>
typedef Csa::char_type&#160;</td><td class="memItemRight" valign="bottom"><b>char_type</b></td></tr>
<tr class="memitem:a83297c9bb2c31cf48444353f6780cb70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83297c9bb2c31cf48444353f6780cb70"></a>
typedef <a class="el" href="structsdsl_1_1lcp__interval.html">lcp_interval</a>&lt; size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a></td></tr>
<tr class="memdesc:a83297c9bb2c31cf48444353f6780cb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for the nodes in the tree. <br/></td></tr>
<tr class="memitem:aa6cd17900d9aa9e24dcab43471d7f090"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6cd17900d9aa9e24dcab43471d7f090"></a>
typedef <a class="el" href="structsdsl_1_1cst__tag.html">cst_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><b>index_category</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ga3b296fd26baf82ee6ca685385ac2f389"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3b296fd26baf82ee6ca685385ac2f389"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__constructors.html#ga3b296fd26baf82ee6ca685385ac2f389">cst_sct</a> ()</td></tr>
<tr class="memdesc:ga3b296fd26baf82ee6ca685385ac2f389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor. <br/></td></tr>
<tr class="memitem:ga013381ac1b740113a75c9126c79f19b2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga013381ac1b740113a75c9126c79f19b2"></a>
template&lt;uint8_t int_width, class size_type_class , uint8_t int_width_1, class size_type_class_1 , uint8_t int_width_2, class size_type_class_2 &gt; </td></tr>
<tr class="memitem:ga013381ac1b740113a75c9126c79f19b2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cst_sct</b> (const std::string &amp;cst_file_name, int_vector_file_buffer&lt; int_width, size_type_class &gt; &amp;lcp_buf, int_vector_file_buffer&lt; int_width_1, size_type_class_1 &gt; &amp;sa_buf, int_vector_file_buffer&lt; int_width_2, size_type_class_2 &gt; &amp;isa_buf, std::string dir, bool build_only_bps)</td></tr>
<tr class="memitem:ga54ec87e1e9f2fc1dcd3b70e45bf51a41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga54ec87e1e9f2fc1dcd3b70e45bf51a41"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>cst_sct</b> (tMSS &amp;file_map, const std::string &amp;dir, const std::string &amp;<a class="el" href="group__cst__sct__tree__methods.html#gabc6abb28b19307fcb58f5b4a0122302f">id</a>, bool build_only_bps)</td></tr>
<tr class="memitem:gac3224e102bcf5a83e4f4fc8d2ecfb2a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__constructors.html#gac3224e102bcf5a83e4f4fc8d2ecfb2a1">cst_sct</a> (const <a class="el" href="classsdsl_1_1cst__sct.html">cst_sct</a> &amp;cst)</td></tr>
<tr class="memdesc:gac3224e102bcf5a83e4f4fc8d2ecfb2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="group__cst__sct__constructors.html#gac3224e102bcf5a83e4f4fc8d2ecfb2a1"></a><br/></td></tr>
<tr class="memitem:a7d59eec28193e514683fcaa4292fd11e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d59eec28193e514683fcaa4292fd11e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>construct</b> (tMSS &amp;file_map, const std::string &amp;dir, const std::string &amp;<a class="el" href="group__cst__sct__tree__methods.html#gabc6abb28b19307fcb58f5b4a0122302f">id</a>, bool build_only_bps)</td></tr>
<tr class="memitem:a5d79355ed6fe4d454cd8cdbfb972f413"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d79355ed6fe4d454cd8cdbfb972f413"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1cst__sct.html#a5d79355ed6fe4d454cd8cdbfb972f413">~cst_sct</a> ()</td></tr>
<tr class="memdesc:a5d79355ed6fe4d454cd8cdbfb972f413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Destructor. <br/></td></tr>
<tr class="memitem:a38ae1f51f72da63086ad57856255a1b7"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1cst__sct.html#a38ae1f51f72da63086ad57856255a1b7">size</a> () const </td></tr>
<tr class="memdesc:a38ae1f51f72da63086ad57856255a1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of leafs of the suffix tree.  <a href="#a38ae1f51f72da63086ad57856255a1b7"></a><br/></td></tr>
<tr class="memitem:a1f079199adefb610fcf8185b0bd7468f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1cst__sct.html#a1f079199adefb610fcf8185b0bd7468f">empty</a> () const </td></tr>
<tr class="memdesc:a1f079199adefb610fcf8185b0bd7468f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the data strucutre is empty.  <a href="#a1f079199adefb610fcf8185b0bd7468f"></a><br/></td></tr>
<tr class="memitem:ad8e290237340017cf3c7d6aa03879aff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1cst__sct.html#ad8e290237340017cf3c7d6aa03879aff">swap</a> (<a class="el" href="classsdsl_1_1cst__sct.html">cst_sct</a>&lt; Csa, Lcp &gt; &amp;cst)</td></tr>
<tr class="memdesc:ad8e290237340017cf3c7d6aa03879aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap method for <a class="el" href="classsdsl_1_1cst__sct.html" title="A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.">cst_sct</a>.  <a href="#ad8e290237340017cf3c7d6aa03879aff"></a><br/></td></tr>
<tr class="memitem:a64d959d27e3ed02210ff055fa1e12108"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsdsl_1_1cst__dfs__const__forward__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1cst__sct.html#a64d959d27e3ed02210ff055fa1e12108">begin</a> () const </td></tr>
<tr class="memdesc:a64d959d27e3ed02210ff055fa1e12108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator to the first element.  <a href="#a64d959d27e3ed02210ff055fa1e12108"></a><br/></td></tr>
<tr class="memitem:a1e759f395583be1a820e1a6ef61bceb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsdsl_1_1cst__dfs__const__forward__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1cst__sct.html#a1e759f395583be1a820e1a6ef61bceb8">end</a> () const </td></tr>
<tr class="memdesc:a1e759f395583be1a820e1a6ef61bceb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator to the element after the last element.  <a href="#a1e759f395583be1a820e1a6ef61bceb8"></a><br/></td></tr>
<tr class="memitem:ada9a2bd2f636b36c5e75aa703d3d6dab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada9a2bd2f636b36c5e75aa703d3d6dab"></a>
<a class="el" href="classsdsl_1_1cst__bottom__up__const__forward__iterator.html">const_bottom_up_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1cst__sct.html#ada9a2bd2f636b36c5e75aa703d3d6dab">begin_bottom_up</a> () const </td></tr>
<tr class="memdesc:ada9a2bd2f636b36c5e75aa703d3d6dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of a bottom-up traversal of the tree. <br/></td></tr>
<tr class="memitem:a8b719576f67e6fcaedb6f92e98321ca8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b719576f67e6fcaedb6f92e98321ca8"></a>
<a class="el" href="classsdsl_1_1cst__bottom__up__const__forward__iterator.html">const_bottom_up_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1cst__sct.html#a8b719576f67e6fcaedb6f92e98321ca8">end_bottom_up</a> () const </td></tr>
<tr class="memdesc:a8b719576f67e6fcaedb6f92e98321ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element after the last element of a bottom-up traversal of the tree. <br/></td></tr>
<tr class="memitem:a88e5364e25c2eec4351772397112ad14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsdsl_1_1cst__sct.html">cst_sct</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1cst__sct.html#a88e5364e25c2eec4351772397112ad14">operator=</a> (const <a class="el" href="classsdsl_1_1cst__sct.html">cst_sct</a> &amp;cst)</td></tr>
<tr class="memdesc:a88e5364e25c2eec4351772397112ad14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment Operator.  <a href="#a88e5364e25c2eec4351772397112ad14"></a><br/></td></tr>
<tr class="memitem:ac0878c1a258eba6bc8cad796ebd7755c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1cst__sct.html#ac0878c1a258eba6bc8cad796ebd7755c">operator==</a> (const <a class="el" href="classsdsl_1_1cst__sct.html">cst_sct</a> &amp;cst) const </td></tr>
<tr class="memdesc:ac0878c1a258eba6bc8cad796ebd7755c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality Operator.  <a href="#ac0878c1a258eba6bc8cad796ebd7755c"></a><br/></td></tr>
<tr class="memitem:a07db7a65187ff470b4626829292b9c74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1cst__sct.html#a07db7a65187ff470b4626829292b9c74">operator!=</a> (const <a class="el" href="classsdsl_1_1cst__sct.html">cst_sct</a> &amp;cst) const </td></tr>
<tr class="memdesc:a07db7a65187ff470b4626829292b9c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unequality Operator.  <a href="#a07db7a65187ff470b4626829292b9c74"></a><br/></td></tr>
<tr class="memitem:aeca749ce2340069293bc66314db8728b"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1cst__sct.html#aeca749ce2340069293bc66314db8728b">serialize</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:aeca749ce2340069293bc66314db8728b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize to a stream.  <a href="#aeca749ce2340069293bc66314db8728b"></a><br/></td></tr>
<tr class="memitem:a2dc38a435e5443651699540ad0106a35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1cst__sct.html#a2dc38a435e5443651699540ad0106a35">load</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:a2dc38a435e5443651699540ad0106a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load from a stream.  <a href="#a2dc38a435e5443651699540ad0106a35"></a><br/></td></tr>
<tr class="memitem:gae423382f6fb59a76dd1c83170775f2a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#gae423382f6fb59a76dd1c83170775f2a1">root</a> () const </td></tr>
<tr class="memdesc:gae423382f6fb59a76dd1c83170775f2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the root of the suffix tree.  <a href="group__cst__sct__tree__methods.html#gae423382f6fb59a76dd1c83170775f2a1"></a><br/></td></tr>
<tr class="memitem:gad928a7652c2aba4ed9b94fa6d3e08229"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#gad928a7652c2aba4ed9b94fa6d3e08229">is_leaf</a> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:gad928a7652c2aba4ed9b94fa6d3e08229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide if a node is a leaf in the suffix tree.  <a href="group__cst__sct__tree__methods.html#gad928a7652c2aba4ed9b94fa6d3e08229"></a><br/></td></tr>
<tr class="memitem:ga767668aeebc47f2a986539f9c6075bb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#ga767668aeebc47f2a986539f9c6075bb3">ith_leaf</a> (size_type i) const </td></tr>
<tr class="memdesc:ga767668aeebc47f2a986539f9c6075bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i-th leaf (1-based from left to right) of the suffix tree.  <a href="group__cst__sct__tree__methods.html#ga767668aeebc47f2a986539f9c6075bb3"></a><br/></td></tr>
<tr class="memitem:gab34595b78f1b0c9a00ee6d7db155deb2"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#gab34595b78f1b0c9a00ee6d7db155deb2">leaves_in_the_subtree</a> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:gab34595b78f1b0c9a00ee6d7db155deb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the number of leaves in the subtree rooted at node v.  <a href="group__cst__sct__tree__methods.html#gab34595b78f1b0c9a00ee6d7db155deb2"></a><br/></td></tr>
<tr class="memitem:gaade14569f23b3d29a19ac74fae449b40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#gaade14569f23b3d29a19ac74fae449b40">leftmost_leaf_in_the_subtree</a> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:gaade14569f23b3d29a19ac74fae449b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the leftmost leaf in the subtree rooted at node v.  <a href="group__cst__sct__tree__methods.html#gaade14569f23b3d29a19ac74fae449b40"></a><br/></td></tr>
<tr class="memitem:ga70f648b615a14aab00fcabb8aec8802f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#ga70f648b615a14aab00fcabb8aec8802f">rightmost_leaf_in_the_subtree</a> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:ga70f648b615a14aab00fcabb8aec8802f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rightmost leaf in the subtree rooted at node v.  <a href="group__cst__sct__tree__methods.html#ga70f648b615a14aab00fcabb8aec8802f"></a><br/></td></tr>
<tr class="memitem:ga8df423c3c2f98735f392456f73d15f9e"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#ga8df423c3c2f98735f392456f73d15f9e">lb</a> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:ga8df423c3c2f98735f392456f73d15f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the index of the leftmost leaf in the corresponding suffix array.  <a href="group__cst__sct__tree__methods.html#ga8df423c3c2f98735f392456f73d15f9e"></a><br/></td></tr>
<tr class="memitem:gab1031a76b72c63559c5da22c13112f85"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#gab1031a76b72c63559c5da22c13112f85">rb</a> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:gab1031a76b72c63559c5da22c13112f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the index of the rightmost leaf in the corresponding suffix array.  <a href="group__cst__sct__tree__methods.html#gab1031a76b72c63559c5da22c13112f85"></a><br/></td></tr>
<tr class="memitem:ga22307ad00719bf309bf18486868c5b52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#ga22307ad00719bf309bf18486868c5b52">parent</a> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:ga22307ad00719bf309bf18486868c5b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the parent node of a node v.  <a href="group__cst__sct__tree__methods.html#ga22307ad00719bf309bf18486868c5b52"></a><br/></td></tr>
<tr class="memitem:gaea137f43d0b8993e541a5226084a4255"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#gaea137f43d0b8993e541a5226084a4255">ith_child</a> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v, size_type i) const </td></tr>
<tr class="memdesc:gaea137f43d0b8993e541a5226084a4255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ith child of a node v.  <a href="group__cst__sct__tree__methods.html#gaea137f43d0b8993e541a5226084a4255"></a><br/></td></tr>
<tr class="memitem:ga5e19709719be98fc178315e712cde1c4"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#ga5e19709719be98fc178315e712cde1c4">degree</a> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:ga5e19709719be98fc178315e712cde1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of children of a node v.  <a href="group__cst__sct__tree__methods.html#ga5e19709719be98fc178315e712cde1c4"></a><br/></td></tr>
<tr class="memitem:ga6e70753a2962fc3d41439a9e1bf9b7ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#ga6e70753a2962fc3d41439a9e1bf9b7ed">sibling</a> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:ga6e70753a2962fc3d41439a9e1bf9b7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next sibling of node v.  <a href="group__cst__sct__tree__methods.html#ga6e70753a2962fc3d41439a9e1bf9b7ed"></a><br/></td></tr>
<tr class="memitem:gac968f7451f13304014318d7a403eb151"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac968f7451f13304014318d7a403eb151"></a>
<a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sibling_naive</b> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v) const </td></tr>
<tr class="memitem:gaf2c83fa9b5378d2424d48070c12b55bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#gaf2c83fa9b5378d2424d48070c12b55bb">child_linear</a> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v, unsigned char c, size_type &amp;char_pos) const </td></tr>
<tr class="memdesc:gaf2c83fa9b5378d2424d48070c12b55bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the child w of v which edge label (v,w) starts with character c.  <a href="group__cst__sct__tree__methods.html#gaf2c83fa9b5378d2424d48070c12b55bb"></a><br/></td></tr>
<tr class="memitem:gaa2b78fdb6b615a807c3caedcd5039b37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#gaa2b78fdb6b615a807c3caedcd5039b37">child</a> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v, const unsigned char c, size_type &amp;char_pos) const </td></tr>
<tr class="memdesc:gaa2b78fdb6b615a807c3caedcd5039b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the child w of node v which edge label (v,w) starts with character c.  <a href="group__cst__sct__tree__methods.html#gaa2b78fdb6b615a807c3caedcd5039b37"></a><br/></td></tr>
<tr class="memitem:ga5a444aafb7f953e6973749ead96d7de1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5a444aafb7f953e6973749ead96d7de1"></a>
<a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#ga5a444aafb7f953e6973749ead96d7de1">child</a> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v, const unsigned char c)</td></tr>
<tr class="memdesc:ga5a444aafb7f953e6973749ead96d7de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the child w of node v which edge label (v,w) starts with character c. <br/></td></tr>
<tr class="memitem:gaa67e743288627d8a40f1d03d3e9329b7"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#gaa67e743288627d8a40f1d03d3e9329b7">edge</a> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v, size_type d) const </td></tr>
<tr class="memdesc:gaa67e743288627d8a40f1d03d3e9329b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the d-th character (1-based indexing) of the edge-label pointing to v.  <a href="group__cst__sct__tree__methods.html#gaa67e743288627d8a40f1d03d3e9329b7"></a><br/></td></tr>
<tr class="memitem:gabf20004081f5604c2e6c33fd7b8cde94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#gabf20004081f5604c2e6c33fd7b8cde94">lca</a> (<a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> v, <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> w) const </td></tr>
<tr class="memdesc:gabf20004081f5604c2e6c33fd7b8cde94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the lowest common ancestor (lca) of two nodes v and w of the suffix tree.  <a href="group__cst__sct__tree__methods.html#gabf20004081f5604c2e6c33fd7b8cde94"></a><br/></td></tr>
<tr class="memitem:ga92ee163c3119232ae8574aa400dab9b9"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#ga92ee163c3119232ae8574aa400dab9b9">depth</a> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:ga92ee163c3119232ae8574aa400dab9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string depth of node v.  <a href="group__cst__sct__tree__methods.html#ga92ee163c3119232ae8574aa400dab9b9"></a><br/></td></tr>
<tr class="memitem:ga4b6ea7562a75e9a2624c8ab41d07e860"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#ga4b6ea7562a75e9a2624c8ab41d07e860">node_depth</a> (<a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> v) const </td></tr>
<tr class="memdesc:ga4b6ea7562a75e9a2624c8ab41d07e860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node depth of node v.  <a href="group__cst__sct__tree__methods.html#ga4b6ea7562a75e9a2624c8ab41d07e860"></a><br/></td></tr>
<tr class="memitem:gae899c37a990eb68614b0bbc4e8712aca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#gae899c37a990eb68614b0bbc4e8712aca">sl</a> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:gae899c37a990eb68614b0bbc4e8712aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the suffix link of node v.  <a href="group__cst__sct__tree__methods.html#gae899c37a990eb68614b0bbc4e8712aca"></a><br/></td></tr>
<tr class="memitem:ga12d25796ed4ae6375279812e68dc9f76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga12d25796ed4ae6375279812e68dc9f76"></a>
<a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#ga12d25796ed4ae6375279812e68dc9f76">wl</a> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v, const unsigned char c) const </td></tr>
<tr class="memdesc:ga12d25796ed4ae6375279812e68dc9f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Weiner link of node v and character c. <br/></td></tr>
<tr class="memitem:gacd563f6bc4c314e2aeea17c9a8eb8504"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#gacd563f6bc4c314e2aeea17c9a8eb8504">sn</a> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:gacd563f6bc4c314e2aeea17c9a8eb8504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the suffix number of a leaf node v.  <a href="group__cst__sct__tree__methods.html#gacd563f6bc4c314e2aeea17c9a8eb8504"></a><br/></td></tr>
<tr class="memitem:gabc6abb28b19307fcb58f5b4a0122302f"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#gabc6abb28b19307fcb58f5b4a0122302f">id</a> (const <a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:gabc6abb28b19307fcb58f5b4a0122302f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a unique identification number for a node of the suffx tree in the range [0..2*size()-1].  <a href="group__cst__sct__tree__methods.html#gabc6abb28b19307fcb58f5b4a0122302f"></a><br/></td></tr>
<tr class="memitem:ga729224f976953cff771cabd95c8336ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga729224f976953cff771cabd95c8336ec"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#ga729224f976953cff771cabd95c8336ec">nodes</a> () const </td></tr>
<tr class="memdesc:ga729224f976953cff771cabd95c8336ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of nodes of the suffix tree. <br/></td></tr>
<tr class="memitem:ga59dbf20fc46cb4d858812e765c03a1ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga59dbf20fc46cb4d858812e765c03a1ea"></a>
<a class="el" href="classsdsl_1_1cst__sct.html#a83297c9bb2c31cf48444353f6780cb70">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#ga59dbf20fc46cb4d858812e765c03a1ea">node</a> (size_type <a class="el" href="group__cst__sct__tree__methods.html#ga8df423c3c2f98735f392456f73d15f9e">lb</a>, size_type <a class="el" href="group__cst__sct__tree__methods.html#gab1031a76b72c63559c5da22c13112f85">rb</a>, size_type l=0) const </td></tr>
<tr class="memdesc:ga59dbf20fc46cb4d858812e765c03a1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node in the suffix tree which corresponds to the lcp-interval [lb..rb]. <br/></td></tr>
<tr class="memitem:ga3a6a8acb7e4dd736ee21b9c0d0b0a68f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3a6a8acb7e4dd736ee21b9c0d0b0a68f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cst__sct__tree__methods.html#ga3a6a8acb7e4dd736ee21b9c0d0b0a68f">print_info</a> () const </td></tr>
<tr class="memdesc:ga3a6a8acb7e4dd736ee21b9c0d0b0a68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print some infos about the size of the compressed suffix tree. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a45fcde796819c67806da2b797782ec33"><td class="memItemLeft" align="right" valign="top">static size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1cst__sct.html#a45fcde796819c67806da2b797782ec33">max_size</a> ()</td></tr>
<tr class="memdesc:a45fcde796819c67806da2b797782ec33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest size that <a class="el" href="classsdsl_1_1cst__sct.html" title="A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.">cst_sct</a> can ever have.  <a href="#a45fcde796819c67806da2b797782ec33"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a1216ba808703e062c0e3e707a3d4a2c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1216ba808703e062c0e3e707a3d4a2c9"></a>
const csa_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1cst__sct.html#a1216ba808703e062c0e3e707a3d4a2c9">csa</a></td></tr>
<tr class="memdesc:a1216ba808703e062c0e3e707a3d4a2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The compressed suffix array the suffix tree is based on. <br/></td></tr>
<tr class="memitem:aa01d82f7359665ab9ceb07942ead0dc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa01d82f7359665ab9ceb07942ead0dc9"></a>
const lcp_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1cst__sct.html#aa01d82f7359665ab9ceb07942ead0dc9">lcp</a></td></tr>
<tr class="memdesc:aa01d82f7359665ab9ceb07942ead0dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lcp array the suffix tree is based on. <br/></td></tr>
<tr class="memitem:a3252574708be08710e0a058621ec26d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3252574708be08710e0a058621ec26d5"></a>
const bit_vector &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1cst__sct.html#a3252574708be08710e0a058621ec26d5">bp</a></td></tr>
<tr class="memdesc:a3252574708be08710e0a058621ec26d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The balanced parentheses sequence of the Super-Cartesian tree the suffix tree is based on. <br/></td></tr>
<tr class="memitem:aa4be9891228e8122a79ffac2a933c2a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4be9891228e8122a79ffac2a933c2a8"></a>
const bp_support_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1cst__sct.html#aa4be9891228e8122a79ffac2a933c2a8">bp_support</a></td></tr>
<tr class="memdesc:aa4be9891228e8122a79ffac2a933c2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The balanced parentheses sequence support for member bp. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Csa = csa_wt&lt;&gt;, class Lcp = lcp_support_sada&lt;Csa&gt;, class Bp_support = bp_support_sada&lt;&gt;&gt;<br/>
class sdsl::cst_sct&lt; Csa, Lcp, Bp_support &gt;</h3>

<p>A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog. </p>
<p>The CST is parameterized by</p>
<ul>
<li>a (compressed) suffix array (accessible via member <img class="formulaInl" alt="$csa$" src="form_108.png"/>, default clas is <a class="el" href="classsdsl_1_1csa__wt.html" title="A class for the Compressed Suffix Array (CSA) based on a Wavelet Tree (WT) of the Burrow Wheeler Tran...">sdsl::csa_wt</a>),</li>
<li>a (compressed) longest common prefix array data structure (accessible via member <img class="formulaInl" alt="$lcp$" src="form_109.png"/>, default class is <a class="el" href="classsdsl_1_1lcp__support__sada.html" title="Helper class which provides _lcp_support_sada the context of a CSA.">sdsl::lcp_support_sada</a>), and</li>
<li>a support data structure for balanced parentheses sequences (accessible via member <img class="formulaInl" alt="$bp\_support$" src="form_110.png"/>, default class is <a class="el" href="classsdsl_1_1bp__support__sada.html" title="A class that provides support for bit_vectors that represent a balanced parentheses sequence...">sdsl::bp_support_sada</a>).</li>
</ul>
<p>It also contains a sdsl::bit_vector which represents the balanced parentheses sequence of the Super-Cartesian tree of the lcp array. This bit_vector can be accessed via the member <img class="formulaInl" alt="$bp$" src="form_111.png"/>.</p>
<p>A node <img class="formulaInl" alt="$v$" src="form_46.png"/> of the csa_sct is represented by an <a class="el" href="structsdsl_1_1lcp__interval.html" title="A struct for the representation of an lcp-interval .">sdsl::lcp_interval</a> . The size of the <a class="el" href="classsdsl_1_1cst__sct.html" title="A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.">sdsl::cst_sct</a> is smaller than the size of a <a class="el" href="classsdsl_1_1cst__sada.html" title="A class for the Compressed Suffix Tree (CST) proposed by Sadakane.">sdsl::cst_sada</a> since the tree topology needs only <img class="formulaInl" alt="$2n$" src="form_155.png"/> bits in contrast to the <img class="formulaInl" alt="$4n$" src="form_113.png"/> bits in <a class="el" href="classsdsl_1_1cst__sada.html" title="A class for the Compressed Suffix Tree (CST) proposed by Sadakane.">sdsl::cst_sada</a>. See the diagram below for an example which gives us the sizes for the compressed suffix arrays for the file english.50MB from the pizza and chili website. </p>
<div class="fragment"><pre class="fragment">  \image html ./example/size_of_csts.png "Size comparison between cst_sct and cst_sada"
  \image latex ./example/size_of_csts.eps  "Size comparison between cst_sct and cst_sada" width=0.7\textwidth</pre></div><p> Applications of the CST: The compressed suffix tree could be used for string matching and many other application in sequence analysis. 17 applications are in the book "Algorithms on Strings, Trees, and Sequences" of Dan Gusfield. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a64d959d27e3ed02210ff055fa1e12108"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa = csa_wt&lt;&gt;, class Lcp = lcp_support_sada&lt;Csa&gt;, class Bp_support = bp_support_sada&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsdsl_1_1cst__dfs__const__forward__iterator.html">const_iterator</a> <a class="el" href="classsdsl_1_1cst__sct.html">sdsl::cst_sct</a>&lt; Csa, Lcp, Bp_support &gt;::<a class="el" href="classsdsl_1_1cst__sct.html#a64d959d27e3ed02210ff055fa1e12108">begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a const_iterator to the first element. </p>
<p>Required for the STL Container Concept. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classsdsl_1_1cst__sct.html#a1e759f395583be1a820e1a6ef61bceb8" title="Returns a const_iterator to the element after the last element.">end</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1f079199adefb610fcf8185b0bd7468f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa = csa_wt&lt;&gt;, class Lcp = lcp_support_sada&lt;Csa&gt;, class Bp_support = bp_support_sada&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsdsl_1_1cst__sct.html">sdsl::cst_sct</a>&lt; Csa, Lcp, Bp_support &gt;::<a class="el" href="classsdsl_1_1cst__sct.html#a1f079199adefb610fcf8185b0bd7468f">empty</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns if the data strucutre is empty. </p>
<p>Required for the Container Concept of the STL.A </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classsdsl_1_1cst__sct.html#a38ae1f51f72da63086ad57856255a1b7" title="Number of leafs of the suffix tree.">size</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1e759f395583be1a820e1a6ef61bceb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa = csa_wt&lt;&gt;, class Lcp = lcp_support_sada&lt;Csa&gt;, class Bp_support = bp_support_sada&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsdsl_1_1cst__dfs__const__forward__iterator.html">const_iterator</a> <a class="el" href="classsdsl_1_1cst__sct.html">sdsl::cst_sct</a>&lt; Csa, Lcp, Bp_support &gt;::<a class="el" href="classsdsl_1_1cst__sct.html#a1e759f395583be1a820e1a6ef61bceb8">end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a const_iterator to the element after the last element. </p>
<p>Required for the STL Container Concept. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classsdsl_1_1cst__sct.html#a64d959d27e3ed02210ff055fa1e12108" title="Returns a const_iterator to the first element.">begin</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2dc38a435e5443651699540ad0106a35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa , class Lcp , class Bp_support &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsdsl_1_1cst__sct.html">sdsl::cst_sct</a>&lt; Csa, Lcp, Bp_support &gt;::<a class="el" href="classsdsl_1_1cst__sct.html#a2dc38a435e5443651699540ad0106a35">load</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load from a stream. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Inputstream to load the data structure from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a45fcde796819c67806da2b797782ec33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa = csa_wt&lt;&gt;, class Lcp = lcp_support_sada&lt;Csa&gt;, class Bp_support = bp_support_sada&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static size_type <a class="el" href="classsdsl_1_1cst__sct.html">sdsl::cst_sct</a>&lt; Csa, Lcp, Bp_support &gt;::<a class="el" href="classsdsl_1_1cst__sct.html#a45fcde796819c67806da2b797782ec33">max_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the largest size that <a class="el" href="classsdsl_1_1cst__sct.html" title="A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.">cst_sct</a> can ever have. </p>
<p>Required for the Container Concept of the STL. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classsdsl_1_1cst__sct.html#a38ae1f51f72da63086ad57856255a1b7" title="Number of leafs of the suffix tree.">size</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a07db7a65187ff470b4626829292b9c74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa = csa_wt&lt;&gt;, class Lcp = lcp_support_sada&lt;Csa&gt;, class Bp_support = bp_support_sada&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsdsl_1_1cst__sct.html">sdsl::cst_sct</a>&lt; Csa, Lcp, Bp_support &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsdsl_1_1cst__sct.html">cst_sct</a>&lt; Csa, Lcp, Bp_support &gt; &amp;&#160;</td>
          <td class="paramname"><em>cst</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unequality Operator. </p>
<p>Two Instances of <a class="el" href="classsdsl_1_1cst__sct.html" title="A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.">cst_sct</a> are equal if not all their members are equal. </p>
<dl class="section user"><dt>Required for the Equality Comparable Concept of the STL.</b></dt><dd></dd></dl>
<dl class="section see"><dt>See also:</dt><dd>operator== </dd></dl>

</div>
</div>
<a class="anchor" id="a88e5364e25c2eec4351772397112ad14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa , class Lcp , class Bp_support &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsdsl_1_1cst__sct.html">cst_sct</a>&lt; Csa, Lcp, Bp_support &gt; &amp; <a class="el" href="classsdsl_1_1cst__sct.html">sdsl::cst_sct</a>&lt; Csa, Lcp, Bp_support &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsdsl_1_1cst__sct.html">cst_sct</a>&lt; Csa, Lcp, Bp_support &gt; &amp;&#160;</td>
          <td class="paramname"><em>cst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment Operator. </p>
<p>Required for the Assignable Concept of the STL. </p>

</div>
</div>
<a class="anchor" id="ac0878c1a258eba6bc8cad796ebd7755c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa = csa_wt&lt;&gt;, class Lcp = lcp_support_sada&lt;Csa&gt;, class Bp_support = bp_support_sada&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsdsl_1_1cst__sct.html">sdsl::cst_sct</a>&lt; Csa, Lcp, Bp_support &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsdsl_1_1cst__sct.html">cst_sct</a>&lt; Csa, Lcp, Bp_support &gt; &amp;&#160;</td>
          <td class="paramname"><em>cst</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equality Operator. </p>
<p>Two Instances of <a class="el" href="classsdsl_1_1cst__sct.html" title="A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.">cst_sct</a> are equal if all their members are equal. </p>
<dl class="section user"><dt>Required for the Equality Comparable Concept of the STL.</b></dt><dd></dd></dl>
<dl class="section see"><dt>See also:</dt><dd>operator!= </dd></dl>

</div>
</div>
<a class="anchor" id="aeca749ce2340069293bc66314db8728b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa , class Lcp , class Bp_support &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsdsl_1_1cst__sct.html">cst_sct</a>&lt; Csa, Lcp, Bp_support &gt;::size_type <a class="el" href="classsdsl_1_1cst__sct.html">sdsl::cst_sct</a>&lt; Csa, Lcp, Bp_support &gt;::<a class="el" href="classsdsl_1_1cst__sct.html#aeca749ce2340069293bc66314db8728b">serialize</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Serialize to a stream. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Outstream to write the data structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The number of written bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a38ae1f51f72da63086ad57856255a1b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa = csa_wt&lt;&gt;, class Lcp = lcp_support_sada&lt;Csa&gt;, class Bp_support = bp_support_sada&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classsdsl_1_1cst__sct.html">sdsl::cst_sct</a>&lt; Csa, Lcp, Bp_support &gt;::<a class="el" href="classsdsl_1_1cst__sct.html#a38ae1f51f72da63086ad57856255a1b7">size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of leafs of the suffix tree. </p>
<p>Required for the Container Concept of the STL. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classsdsl_1_1cst__sct.html#a45fcde796819c67806da2b797782ec33" title="Returns the largest size that cst_sct can ever have.">max_size</a>, <a class="el" href="classsdsl_1_1cst__sct.html#a1f079199adefb610fcf8185b0bd7468f" title="Returns if the data strucutre is empty.">empty</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad8e290237340017cf3c7d6aa03879aff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa = csa_wt&lt;&gt;, class Lcp = lcp_support_sada&lt;Csa&gt;, class Bp_support = bp_support_sada&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsdsl_1_1cst__sct.html">sdsl::cst_sct</a>&lt; Csa, Lcp, Bp_support &gt;::<a class="el" href="classsdsl_1_1cst__sct.html#ad8e290237340017cf3c7d6aa03879aff">swap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsdsl_1_1cst__sct.html">cst_sct</a>&lt; Csa, Lcp &gt; &amp;&#160;</td>
          <td class="paramname"><em>cst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap method for <a class="el" href="classsdsl_1_1cst__sct.html" title="A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.">cst_sct</a>. </p>
<p>The swap method can be defined in terms of assignment. This requires three assignments, each of which, for a container type, is linear in the container's size. In a sense, then, a.swap(b) is redundant. This implementation guaranties a run-time complexity that is constant rather than linear. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cst</td><td><a class="el" href="classsdsl_1_1cst__sct.html" title="A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.">cst_sct</a> to swap.</td></tr>
  </table>
  </dd>
</dl>
<p>Required for the Assignable Conecpt of the STL. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>sdsl/include/sdsl/<a class="el" href="cst__sct_8hpp_source.html">cst_sct.hpp</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 30 2012 16:04:35 for Succinct Data Structure Library (sdsl) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
