<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>SDSL: Succinct Data Structure Library: sdsl::_lcp_support_sada&lt; Csa, BitVector, SelectSupport &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">SDSL: Succinct Data Structure Library
   
   </div>
   <div id="projectbrief">A C++ template library for succinct data structures</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00285.html">sdsl</a>      </li>
      <li class="navelem"><a class="el" href="a00006.html">_lcp_support_sada</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">sdsl::_lcp_support_sada&lt; Csa, BitVector, SelectSupport &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class for the compressed version of lcp information of an suffix array of class Csa proposed by Sadakane in the paper "Succinct Representation of lcp Information and Improvements in the Compressed Suffix Arrays".  
 <a href="a00006.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00231_source.html">lcp_support_sada.hpp</a>&gt;</code></p>

<p><a href="a00386.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html">type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a189fccd48ab70276e2d46bb886739843"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>fast_access</b> =  0, 
<b>text_order</b> =  1, 
<b>sa_order</b> =  0
 }</td></tr>
<tr class="memitem:abe128a4b59c060b8eee59e47b43879cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe128a4b59c060b8eee59e47b43879cf"></a>
typedef Csa::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="memitem:aaec5a8958b901f4872a04db21f46da35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaec5a8958b901f4872a04db21f46da35"></a>
typedef <br class="typebreak"/>
<a class="el" href="a00111.html">random_access_const_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="a00006.html">_lcp_support_sada</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="memitem:a3429497365fa97236e475527e96a4536"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3429497365fa97236e475527e96a4536"></a>
typedef <a class="el" href="a00111.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="memitem:ae72b9c2ce89e37d073e8841f1ef470cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae72b9c2ce89e37d073e8841f1ef470cc"></a>
typedef const value_type&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="memitem:ac992a252f968ee0565da2b0b69c7cca6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac992a252f968ee0565da2b0b69c7cca6"></a>
typedef const_reference&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="memitem:a3b16bd5806437758b71158913d4b7d8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b16bd5806437758b71158913d4b7d8a"></a>
typedef const_reference *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="memitem:a66af609d000c2819b3a228834cc23b9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66af609d000c2819b3a228834cc23b9a"></a>
typedef const pointer&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="memitem:a0f426589b805d4dde80d67baf1b7c73b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f426589b805d4dde80d67baf1b7c73b"></a>
typedef int_vector::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="memitem:a5008f12300d6eeaa3cb01cfd40d6b8d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5008f12300d6eeaa3cb01cfd40d6b8d6"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="memitem:a9f68830771da93c86ed5d540d93bba20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f68830771da93c86ed5d540d93bba20"></a>
typedef BitVector&#160;</td><td class="memItemRight" valign="bottom"><b>bit_vector_type</b></td></tr>
<tr class="memitem:a87d44ef54d7c0e6c52b6f35815e2cce8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87d44ef54d7c0e6c52b6f35815e2cce8"></a>
typedef Csa&#160;</td><td class="memItemRight" valign="bottom"><b>csa_type</b></td></tr>
<tr class="memitem:a8d9d97923412e898a96d2dff481a1446"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d9d97923412e898a96d2dff481a1446"></a>
typedef <a class="el" href="a00091.html">lcp_permuted_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lcp_category</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abbd9599d48cbda926e6a99dee4035148"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbd9599d48cbda926e6a99dee4035148"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#abbd9599d48cbda926e6a99dee4035148">_lcp_support_sada</a> ()</td></tr>
<tr class="memdesc:abbd9599d48cbda926e6a99dee4035148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor. <br/></td></tr>
<tr class="memitem:a8ea470a7213e92d8b2537fec6ce3dcbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ea470a7213e92d8b2537fec6ce3dcbb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a8ea470a7213e92d8b2537fec6ce3dcbb">~_lcp_support_sada</a> ()</td></tr>
<tr class="memdesc:a8ea470a7213e92d8b2537fec6ce3dcbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Destructor. <br/></td></tr>
<tr class="memitem:a8dab5c1163b54a3a0dd20fbaf9a0265b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dab5c1163b54a3a0dd20fbaf9a0265b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a8dab5c1163b54a3a0dd20fbaf9a0265b">_lcp_support_sada</a> (const <a class="el" href="a00006.html">_lcp_support_sada</a> &amp;lcp_c)</td></tr>
<tr class="memdesc:a8dab5c1163b54a3a0dd20fbaf9a0265b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr class="memitem:a6fa95a2204f2c7f2da599fbb0d037429"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6fa95a2204f2c7f2da599fbb0d037429"></a>
template&lt;class Text , class Sa &gt; </td></tr>
<tr class="memitem:a6fa95a2204f2c7f2da599fbb0d037429"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00006.html#a6fa95a2204f2c7f2da599fbb0d037429">_lcp_support_sada</a> (const Text &amp;text, const Sa &amp;sa, const Csa *csa)</td></tr>
<tr class="memdesc:a6fa95a2204f2c7f2da599fbb0d037429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the compressed lcp from a suffix array and a text. <br/></td></tr>
<tr class="memitem:ab0cefe44c5215c1b1457c353edd1996b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab0cefe44c5215c1b1457c353edd1996b"></a>
template&lt;uint8_t int_width, class size_type_class , uint8_t int_width_1, class size_type_class_1 &gt; </td></tr>
<tr class="memitem:ab0cefe44c5215c1b1457c353edd1996b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00006.html#ab0cefe44c5215c1b1457c353edd1996b">_lcp_support_sada</a> (<a class="el" href="a00070.html">int_vector_file_buffer</a>&lt; int_width, size_type_class &gt; &amp;lcp_buf, <a class="el" href="a00070.html">int_vector_file_buffer</a>&lt; int_width_1, size_type_class_1 &gt; &amp;isa_buf, const Csa *f_csa)</td></tr>
<tr class="memdesc:ab0cefe44c5215c1b1457c353edd1996b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the lcp array from an lcp array and an <a class="el" href="a00070.html" title="A class for reading an int_vector buffered from a file.">int_vector_file_buffer</a> of the inverse suffix array. <br/></td></tr>
<tr class="memitem:a4c29d4e640c4d74c3d05af9da843dc40"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4c29d4e640c4d74c3d05af9da843dc40"></a>
template&lt;class Text , class Sa &gt; </td></tr>
<tr class="memitem:a4c29d4e640c4d74c3d05af9da843dc40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>construct</b> (const Text &amp;text, const Sa &amp;sa, const Csa *csa)</td></tr>
<tr class="memitem:a3c2d809eb1512cd7240714854f7937ef"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c2d809eb1512cd7240714854f7937ef"></a>
template&lt;uint8_t int_width, class size_type_class , uint8_t int_width_1, class size_type_class_1 &gt; </td></tr>
<tr class="memitem:a3c2d809eb1512cd7240714854f7937ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>construct</b> (<a class="el" href="a00070.html">int_vector_file_buffer</a>&lt; int_width, size_type_class &gt; &amp;lcp_buf, <a class="el" href="a00070.html">int_vector_file_buffer</a>&lt; int_width_1, size_type_class_1 &gt; &amp;isa_buf, const Csa *f_csa)</td></tr>
<tr class="memitem:a3bbaf25d340b7334b265c99230be6b53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bbaf25d340b7334b265c99230be6b53"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_csa</b> (const Csa *f_csa)</td></tr>
<tr class="memitem:a0da6e6a77bb451ea50e7470f4c51f847"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a0da6e6a77bb451ea50e7470f4c51f847">size</a> () const </td></tr>
<tr class="memdesc:a0da6e6a77bb451ea50e7470f4c51f847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements in the instance.  <a href="#a0da6e6a77bb451ea50e7470f4c51f847"></a><br/></td></tr>
<tr class="memitem:a8771a6eae66a893a1a310bc87528e24c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a8771a6eae66a893a1a310bc87528e24c">empty</a> () const </td></tr>
<tr class="memdesc:a8771a6eae66a893a1a310bc87528e24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the data strucutre is empty.  <a href="#a8771a6eae66a893a1a310bc87528e24c"></a><br/></td></tr>
<tr class="memitem:aa6acdc79b8b9a8af7b691c8bbda84a0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#aa6acdc79b8b9a8af7b691c8bbda84a0d">swap</a> (<a class="el" href="a00006.html">_lcp_support_sada</a> &amp;lcp_c)</td></tr>
<tr class="memdesc:aa6acdc79b8b9a8af7b691c8bbda84a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap method for <a class="el" href="a00006.html" title="A class for the compressed version of lcp information of an suffix array of class Csa proposed by Sad...">_lcp_support_sada</a>.  <a href="#aa6acdc79b8b9a8af7b691c8bbda84a0d"></a><br/></td></tr>
<tr class="memitem:a1a5b6ef1b818b7e26260c5da164a0614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00111.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a1a5b6ef1b818b7e26260c5da164a0614">begin</a> () const </td></tr>
<tr class="memdesc:a1a5b6ef1b818b7e26260c5da164a0614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator to the first element.  <a href="#a1a5b6ef1b818b7e26260c5da164a0614"></a><br/></td></tr>
<tr class="memitem:acee345cd166f507f1ae1042c8d920942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00111.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#acee345cd166f507f1ae1042c8d920942">end</a> () const </td></tr>
<tr class="memdesc:acee345cd166f507f1ae1042c8d920942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator to the element after the last element.  <a href="#acee345cd166f507f1ae1042c8d920942"></a><br/></td></tr>
<tr class="memitem:a18481511221458d486371a90e7a8219d"><td class="memItemLeft" align="right" valign="top">value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a18481511221458d486371a90e7a8219d">operator[]</a> (size_type i) const </td></tr>
<tr class="memdesc:a18481511221458d486371a90e7a8219d"><td class="mdescLeft">&#160;</td><td class="mdescRight">[]-operator  <a href="#a18481511221458d486371a90e7a8219d"></a><br/></td></tr>
<tr class="memitem:a3dae835e503b8a2517d3704b991cd3fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html">_lcp_support_sada</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a3dae835e503b8a2517d3704b991cd3fd">operator=</a> (const <a class="el" href="a00006.html">_lcp_support_sada</a> &amp;lcp_c)</td></tr>
<tr class="memdesc:a3dae835e503b8a2517d3704b991cd3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment Operator.  <a href="#a3dae835e503b8a2517d3704b991cd3fd"></a><br/></td></tr>
<tr class="memitem:a855591850b4c9b467692b499abbcc8ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a855591850b4c9b467692b499abbcc8ef">operator==</a> (const <a class="el" href="a00006.html">_lcp_support_sada</a> &amp;lcp_c) const </td></tr>
<tr class="memdesc:a855591850b4c9b467692b499abbcc8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality Operator.  <a href="#a855591850b4c9b467692b499abbcc8ef"></a><br/></td></tr>
<tr class="memitem:a86c7b29860ba0dd682a10b249cb7e172"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a86c7b29860ba0dd682a10b249cb7e172">operator!=</a> (const <a class="el" href="a00006.html">_lcp_support_sada</a> &amp;lcp_c) const </td></tr>
<tr class="memdesc:a86c7b29860ba0dd682a10b249cb7e172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unequality Operator.  <a href="#a86c7b29860ba0dd682a10b249cb7e172"></a><br/></td></tr>
<tr class="memitem:a6b623601abb9ca7cd878e639d2d6f760"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a6b623601abb9ca7cd878e639d2d6f760">serialize</a> (std::ostream &amp;out, <a class="el" href="a00157.html">structure_tree_node</a> *v=NULL, std::string name=&quot;&quot;) const </td></tr>
<tr class="memdesc:a6b623601abb9ca7cd878e639d2d6f760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize to a stream.  <a href="#a6b623601abb9ca7cd878e639d2d6f760"></a><br/></td></tr>
<tr class="memitem:ae64ee3b7513131203082d9ccc916ccba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ae64ee3b7513131203082d9ccc916ccba">load</a> (std::istream &amp;in, const Csa *csa)</td></tr>
<tr class="memdesc:ae64ee3b7513131203082d9ccc916ccba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load from a stream.  <a href="#ae64ee3b7513131203082d9ccc916ccba"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8bfe694f8defdb38e24bc2a7075a6611"><td class="memItemLeft" align="right" valign="top">static size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a8bfe694f8defdb38e24bc2a7075a6611">max_size</a> ()</td></tr>
<tr class="memdesc:a8bfe694f8defdb38e24bc2a7075a6611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest size that <a class="el" href="a00006.html" title="A class for the compressed version of lcp information of an suffix array of class Csa proposed by Sad...">_lcp_support_sada</a> can ever have.  <a href="#a8bfe694f8defdb38e24bc2a7075a6611"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a52d355e2aa9462ff5bb170bb95e183bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52d355e2aa9462ff5bb170bb95e183bf"></a>
const Csa *&amp;&#160;</td><td class="memItemRight" valign="bottom"><b>csa</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Csa = csa_sada&lt;&gt;, class BitVector = bit_vector, class SelectSupport = typename BitVector::select_1_type&gt;<br/>
class sdsl::_lcp_support_sada&lt; Csa, BitVector, SelectSupport &gt;</h3>

<p>A class for the compressed version of lcp information of an suffix array of class Csa proposed by Sadakane in the paper "Succinct Representation of lcp Information and Improvements in the Compressed Suffix Arrays". </p>
<p>The class has two template parameters:</p>
<ul>
<li><em>Csa</em> is the (compressed) suffix array for which the lcp information should by provided.</li>
<li><p class="startli"><em>SelectSupport</em> is the SelectSupport class which is used in the data structure to calculate the select queries.</p>
<dl class="section user"><dt>Space complexity</b></dt><dd><img class="formulaInl" alt="$ 2n+o(n) $" src="form_186.png"/> bits, where 2n is the maximal size of the bitvector for the differences of the PLCP array and o(n) for the select support data structure.</dd></dl>
<p>The representation of the lcp information corresponds to the concept of an immutable random access container of the STL. </p>
</li>
</ul>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1a5b6ef1b818b7e26260c5da164a0614"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa , class BitVector , class SelectSupport &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html">_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt;::<a class="el" href="a00111.html">const_iterator</a> <a class="el" href="a00006.html">sdsl::_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt;::<a class="el" href="a00006.html#a1a5b6ef1b818b7e26260c5da164a0614">begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a const_iterator to the first element. </p>
<p>Required for the STL Container Concept. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="a00006.html#acee345cd166f507f1ae1042c8d920942" title="Returns a const_iterator to the element after the last element.">end</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8771a6eae66a893a1a310bc87528e24c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa = csa_sada&lt;&gt;, class BitVector = bit_vector, class SelectSupport = typename BitVector::select_1_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00006.html">sdsl::_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt;::<a class="el" href="a00006.html#a8771a6eae66a893a1a310bc87528e24c">empty</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns if the data strucutre is empty. </p>
<p>Required for the Container Concept of the STL.A </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="a00006.html#a0da6e6a77bb451ea50e7470f4c51f847" title="Number of elements in the instance.">size</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acee345cd166f507f1ae1042c8d920942"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa , class BitVector , class SelectSupport &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html">_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt;::<a class="el" href="a00111.html">const_iterator</a> <a class="el" href="a00006.html">sdsl::_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt;::<a class="el" href="a00006.html#acee345cd166f507f1ae1042c8d920942">end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a const_iterator to the element after the last element. </p>
<p>Required for the STL Container Concept. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="a00006.html#a1a5b6ef1b818b7e26260c5da164a0614" title="Returns a const_iterator to the first element.">begin</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae64ee3b7513131203082d9ccc916ccba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa, class BitVector , class SelectSupport &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00006.html">sdsl::_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt;::<a class="el" href="a00006.html#ae64ee3b7513131203082d9ccc916ccba">load</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Csa *&#160;</td>
          <td class="paramname"><em>csa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load from a stream. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Inputstream to load the data structure from. </td></tr>
    <tr><td class="paramname">csa</td><td>Compressed Suffix Array that is supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8bfe694f8defdb38e24bc2a7075a6611"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa = csa_sada&lt;&gt;, class BitVector = bit_vector, class SelectSupport = typename BitVector::select_1_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static size_type <a class="el" href="a00006.html">sdsl::_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt;::<a class="el" href="a00006.html#a8bfe694f8defdb38e24bc2a7075a6611">max_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the largest size that <a class="el" href="a00006.html" title="A class for the compressed version of lcp information of an suffix array of class Csa proposed by Sad...">_lcp_support_sada</a> can ever have. </p>
<p>Required for the Container Concept of the STL. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="a00006.html#a0da6e6a77bb451ea50e7470f4c51f847" title="Number of elements in the instance.">size</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a86c7b29860ba0dd682a10b249cb7e172"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa , class BitVector , class SelectSupport &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00006.html">sdsl::_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html">_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt; &amp;&#160;</td>
          <td class="paramname"><em>lcp_c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unequality Operator. </p>
<p>Two Instances of <a class="el" href="a00006.html" title="A class for the compressed version of lcp information of an suffix array of class Csa proposed by Sad...">_lcp_support_sada</a> are equal if not all their members are equal. </p>
<dl class="section user"><dt>Required for the Equality Comparable Concept of the STL.</b></dt><dd></dd></dl>
<dl class="section see"><dt>See also:</dt><dd>operator== </dd></dl>

</div>
</div>
<a class="anchor" id="a3dae835e503b8a2517d3704b991cd3fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa , class BitVector , class SelectSupport &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html">_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt; &amp; <a class="el" href="a00006.html">sdsl::_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html">_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt; &amp;&#160;</td>
          <td class="paramname"><em>lcp_c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment Operator. </p>
<p>Required for the Assignable Concept of the STL. </p>

</div>
</div>
<a class="anchor" id="a855591850b4c9b467692b499abbcc8ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa , class BitVector , class SelectSupport &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00006.html">sdsl::_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html">_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt; &amp;&#160;</td>
          <td class="paramname"><em>lcp_c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equality Operator. </p>
<p>Two Instances of <a class="el" href="a00006.html" title="A class for the compressed version of lcp information of an suffix array of class Csa proposed by Sad...">_lcp_support_sada</a> are equal if all their members are equal. </p>
<dl class="section user"><dt>Required for the Equality Comparable Concept of the STL.</b></dt><dd></dd></dl>
<dl class="section see"><dt>See also:</dt><dd>operator!= </dd></dl>

</div>
</div>
<a class="anchor" id="a18481511221458d486371a90e7a8219d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa , class BitVector , class SelectSupport &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html">_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt;::value_type <a class="el" href="a00006.html">sdsl::_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>[]-operator </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of the value. <img class="formulaInl" alt="$ i \in [0..size()-1]$" src="form_92.png"/>. Time complexity: O(suffix array access) Required for the STL Random Access Container Concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b623601abb9ca7cd878e639d2d6f760"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa , class BitVector , class SelectSupport &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html">_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt;::size_type <a class="el" href="a00006.html">sdsl::_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt;::<a class="el" href="a00006.html#a6b623601abb9ca7cd878e639d2d6f760">serialize</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00157.html">structure_tree_node</a> *&#160;</td>
          <td class="paramname"><em>v</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Serialize to a stream. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Outstream to write the data structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The number of written bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a0da6e6a77bb451ea50e7470f4c51f847"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa = csa_sada&lt;&gt;, class BitVector = bit_vector, class SelectSupport = typename BitVector::select_1_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="a00006.html">sdsl::_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt;::<a class="el" href="a00006.html#a0da6e6a77bb451ea50e7470f4c51f847">size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of elements in the instance. </p>
<p>Required for the Container Concept of the STL. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="a00006.html#a8bfe694f8defdb38e24bc2a7075a6611" title="Returns the largest size that _lcp_support_sada can ever have.">max_size</a>, <a class="el" href="a00006.html#a8771a6eae66a893a1a310bc87528e24c" title="Returns if the data strucutre is empty.">empty</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa6acdc79b8b9a8af7b691c8bbda84a0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa , class BitVector , class SelectSupport &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00006.html">sdsl::_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt;::<a class="el" href="a00006.html#aa6acdc79b8b9a8af7b691c8bbda84a0d">swap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00006.html">_lcp_support_sada</a>&lt; Csa, BitVector, SelectSupport &gt; &amp;&#160;</td>
          <td class="paramname"><em>lcp_c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap method for <a class="el" href="a00006.html" title="A class for the compressed version of lcp information of an suffix array of class Csa proposed by Sad...">_lcp_support_sada</a>. </p>
<p>The swap method can be defined in terms of assignment. This requires three assignments, each of which, for a container type, is linear in the container's size. In a sense, then, a.swap(b) is redundant. This implementation guaranties a run-time complexity that is constant rather than linear. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lcp_c</td><td><a class="el" href="a00006.html" title="A class for the compressed version of lcp information of an suffix array of class Csa proposed by Sad...">_lcp_support_sada</a> to swap.</td></tr>
  </table>
  </dd>
</dl>
<p>Required for the Assignable Conecpt of the STL. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>sdsl/include/sdsl/<a class="el" href="a00231_source.html">lcp_support_sada.hpp</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 13 2012 15:23:28 for SDSL: Succinct Data Structure Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
