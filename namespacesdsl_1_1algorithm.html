<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>SDSL: Succinct Data Structure Library: sdsl::algorithm Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">SDSL: Succinct Data Structure Library
   
   </div>
   <div id="projectbrief">A C++ template library for succinct data structures</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacesdsl.html">sdsl</a>      </li>
      <li class="navelem"><a class="el" href="namespacesdsl_1_1algorithm.html">algorithm</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sdsl::algorithm Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A helper class containing algorithms for succinct data structures.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a38f909df0f34bec09d2e59a4fdea52f1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#a38f909df0f34bec09d2e59a4fdea52f1">H_0</a> (const unsigned char *c)</td></tr>
<tr class="memdesc:a38f909df0f34bec09d2e59a4fdea52f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the zero-order entropy for a text T.  <a href="#a38f909df0f34bec09d2e59a4fdea52f1"></a><br/></td></tr>
<tr class="memitem:aef450f2394cb9eaebfbcc1a19c827e24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef450f2394cb9eaebfbcc1a19c827e24"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>H_0s</b> (const unsigned char *c)</td></tr>
<tr class="memitem:a4b56b5bd8cfa769ca13436a3615cc5ae"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessContainer1 , class RandomAccessContainer2 &gt; </td></tr>
<tr class="memitem:a4b56b5bd8cfa769ca13436a3615cc5ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#a4b56b5bd8cfa769ca13436a3615cc5ae">calculate_psv</a> (const RandomAccessContainer1 &amp;a, RandomAccessContainer2 &amp;psv)</td></tr>
<tr class="memdesc:a4b56b5bd8cfa769ca13436a3615cc5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the previous smaller value (psv) array for a random access container a.  <a href="#a4b56b5bd8cfa769ca13436a3615cc5ae"></a><br/></td></tr>
<tr class="memitem:aad3d575e4af846500969776005d27db1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#aad3d575e4af846500969776005d27db1">calculate_pioneers_bitmap</a> (const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, bit_vector::size_type block_size, <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;pioneer_bitmap)</td></tr>
<tr class="memdesc:aad3d575e4af846500969776005d27db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate pioneers as defined in the paper of Geary et al. (CPM 2004)  <a href="#aad3d575e4af846500969776005d27db1"></a><br/></td></tr>
<tr class="memitem:acb1eb31bc30f95a024b84b7cc4cad60f"><td class="memTemplParams" colspan="2">template&lt;class size_type &gt; </td></tr>
<tr class="memitem:acb1eb31bc30f95a024b84b7cc4cad60f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#acb1eb31bc30f95a024b84b7cc4cad60f">calculate_pioneers_bitmap_succinct</a> (const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, size_type block_size, <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;pioneer_bitmap)</td></tr>
<tr class="memdesc:acb1eb31bc30f95a024b84b7cc4cad60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate pioneers as defined in the paper of Geary et al. (CPM 2004) with few extra space.  <a href="#acb1eb31bc30f95a024b84b7cc4cad60f"></a><br/></td></tr>
<tr class="memitem:ae8ee94e79d7bcb7fde33c4a309a613f9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae8ee94e79d7bcb7fde33c4a309a613f9"></a>
template&lt;class size_type &gt; </td></tr>
<tr class="memitem:ae8ee94e79d7bcb7fde33c4a309a613f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>calculate_pioneers_bitmap_succinct2</b> (const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, size_type block_size, <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;pioneer_bitmap)</td></tr>
<tr class="memitem:ab7dd2a643b582a46ef854f91c7b5534a"><td class="memTemplParams" colspan="2">template&lt;class int_vector &gt; </td></tr>
<tr class="memitem:ab7dd2a643b582a46ef854f91c7b5534a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#ab7dd2a643b582a46ef854f91c7b5534a">calculate_matches</a> (const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, <a class="el" href="classsdsl_1_1int__vector.html">int_vector</a> &amp;matches)</td></tr>
<tr class="memdesc:ab7dd2a643b582a46ef854f91c7b5534a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates matches (i.e. find_open for a closing parenthesis and find_close for an opening parenthesis)  <a href="#ab7dd2a643b582a46ef854f91c7b5534a"></a><br/></td></tr>
<tr class="memitem:a1e92120cfb8f1d8c947a89f229a0b8e6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1e92120cfb8f1d8c947a89f229a0b8e6"></a>
template&lt;class int_vector &gt; </td></tr>
<tr class="memitem:a1e92120cfb8f1d8c947a89f229a0b8e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>calculate_matches_for_pioneers</b> (const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;pioneer_bitmap, <a class="el" href="classsdsl_1_1int__vector.html">int_vector</a> &amp;matches)</td></tr>
<tr class="memitem:a1a946037a85f7b270054c1765220c18d"><td class="memTemplParams" colspan="2">template&lt;class int_vector &gt; </td></tr>
<tr class="memitem:a1a946037a85f7b270054c1765220c18d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#a1a946037a85f7b270054c1765220c18d">calculate_enclose</a> (const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, <a class="el" href="classsdsl_1_1int__vector.html">int_vector</a> &amp;enclose)</td></tr>
<tr class="memdesc:a1a946037a85f7b270054c1765220c18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates enclose answers for a balanced parentheses sequence.  <a href="#a1a946037a85f7b270054c1765220c18d"></a><br/></td></tr>
<tr class="memitem:a1bb1b7ec7c1b10d63db871a6e68671f1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1bb1b7ec7c1b10d63db871a6e68671f1"></a>
template&lt;class bp_support &gt; </td></tr>
<tr class="memitem:a1bb1b7ec7c1b10d63db871a6e68671f1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>check_bp_support</b> (const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, bp_support bp_s)</td></tr>
<tr class="memitem:a2784d01a7b9c1fa332e1278b246ccc68"><td class="memItemLeft" align="right" valign="top">bit_vector::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#a2784d01a7b9c1fa332e1278b246ccc68">near_find_close_naive</a> (const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, bit_vector::size_type i, const bit_vector::size_type block_size)</td></tr>
<tr class="memdesc:a2784d01a7b9c1fa332e1278b246ccc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the near closing parenthesis if it exists.  <a href="#a2784d01a7b9c1fa332e1278b246ccc68"></a><br/></td></tr>
<tr class="memitem:af266dfab0ce932216697d6fe686d0ac4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af266dfab0ce932216697d6fe686d0ac4"></a>
bit_vector::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>near_find_close</b> (const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, const bit_vector::size_type i, const bit_vector::size_type block_size)</td></tr>
<tr class="memitem:a48058205b220be6fb4769113229ca628"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48058205b220be6fb4769113229ca628"></a>
bit_vector::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>near_find_closing</b> (const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, bit_vector::size_type i, bit_vector::size_type closings, const bit_vector::size_type block_size)</td></tr>
<tr class="memitem:a772cc32d6b1183bc7879d1e399c9758e"><td class="memItemLeft" align="right" valign="top">bit_vector::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#a772cc32d6b1183bc7879d1e399c9758e">near_fwd_excess</a> (const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, bit_vector::size_type i, bit_vector::difference_type rel, const bit_vector::size_type block_size)</td></tr>
<tr class="memdesc:a772cc32d6b1183bc7879d1e399c9758e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method searches the minimal parenthesis j, with j&gt;=i, such that excess(j) = excess(i-1)+rel.  <a href="#a772cc32d6b1183bc7879d1e399c9758e"></a><br/></td></tr>
<tr class="memitem:a1330e14ac6487679fc85942a188d8e34"><td class="memItemLeft" align="right" valign="top">bit_vector::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#a1330e14ac6487679fc85942a188d8e34">near_rmq</a> (const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, bit_vector::size_type l, bit_vector::size_type r, bit_vector::difference_type &amp;min_rel_ex)</td></tr>
<tr class="memdesc:a1330e14ac6487679fc85942a188d8e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the position with minimal excess value in the interval [l..r].  <a href="#a1330e14ac6487679fc85942a188d8e34"></a><br/></td></tr>
<tr class="memitem:a1d6c53e2e8f22a71de82750d8f472cb2"><td class="memItemLeft" align="right" valign="top">bit_vector::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#a1d6c53e2e8f22a71de82750d8f472cb2">near_bwd_excess</a> (const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, bit_vector::size_type i, bit_vector::difference_type rel, const bit_vector::size_type block_size)</td></tr>
<tr class="memdesc:a1d6c53e2e8f22a71de82750d8f472cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method searches the maximal parenthesis j, with <img class="formulaInl" alt="$ j\leq i $" src="form_23.png"/>, such that <img class="formulaInl" alt="$ excess(j) = excess(i+1)+rel $" src="form_24.png"/> and.  <a href="#a1d6c53e2e8f22a71de82750d8f472cb2"></a><br/></td></tr>
<tr class="memitem:aa17028f3a5eec3834f1d1b86415eb48f"><td class="memItemLeft" align="right" valign="top">bit_vector::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#aa17028f3a5eec3834f1d1b86415eb48f">near_find_open_naive</a> (const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, bit_vector::size_type i, const bit_vector::size_type block_size)</td></tr>
<tr class="memdesc:aa17028f3a5eec3834f1d1b86415eb48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the near opening parenthesis if it exists.  <a href="#aa17028f3a5eec3834f1d1b86415eb48f"></a><br/></td></tr>
<tr class="memitem:abdc6b8b97fe0ec4126fe89c2bead4514"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdc6b8b97fe0ec4126fe89c2bead4514"></a>
bit_vector::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>near_find_open</b> (const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, bit_vector::size_type i, const bit_vector::size_type block_size)</td></tr>
<tr class="memitem:a37af6607f56b01e92abe9e1c0af0fd6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37af6607f56b01e92abe9e1c0af0fd6c"></a>
bit_vector::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>near_find_opening</b> (const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, bit_vector::size_type i, const bit_vector::size_type openings, const bit_vector::size_type block_size)</td></tr>
<tr class="memitem:a88e65161b14a1a12aebeddc9cf0300f2"><td class="memItemLeft" align="right" valign="top">bit_vector::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#a88e65161b14a1a12aebeddc9cf0300f2">near_enclose</a> (const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, bit_vector::size_type i, const bit_vector::size_type block_size)</td></tr>
<tr class="memdesc:a88e65161b14a1a12aebeddc9cf0300f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the opening parenthesis of the enclosing pair if this parenthesis is near.  <a href="#a88e65161b14a1a12aebeddc9cf0300f2"></a><br/></td></tr>
<tr class="memitem:a16277e0b872f830322920075fba45a24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16277e0b872f830322920075fba45a24"></a>
bit_vector::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>near_rmq_open</b> (const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, const bit_vector::size_type begin, const bit_vector::size_type end)</td></tr>
<tr class="memitem:a2622eb9339554330c87a51b84f08ece5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2622eb9339554330c87a51b84f08ece5"></a>
bit_vector::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>near_rmq_open_naive</b> (const <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, const bit_vector::size_type begin, const bit_vector::size_type end)</td></tr>
<tr class="memitem:afae6127ee2e472108d9294465de9a818"><td class="memTemplParams" colspan="2"><a class="anchor" id="afae6127ee2e472108d9294465de9a818"></a>
template&lt;class Csa &gt; </td></tr>
<tr class="memitem:afae6127ee2e472108d9294465de9a818"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_text</b> (const unsigned char *str, typename Csa::size_type len, <a class="el" href="classsdsl_1_1int__vector.html">int_vector</a>&lt; 64 &gt; &amp;C, <a class="el" href="classsdsl_1_1int__vector.html">int_vector</a>&lt; 8 &gt; &amp;char2comp, <a class="el" href="classsdsl_1_1int__vector.html">int_vector</a>&lt; 8 &gt; &amp;comp2char, uint16_t &amp;sigma)</td></tr>
<tr class="memitem:aeef0e09312b22a0188b77c432823ffdc"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeef0e09312b22a0188b77c432823ffdc"></a>
template&lt;class Csa , class size_type_class &gt; </td></tr>
<tr class="memitem:aeef0e09312b22a0188b77c432823ffdc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_text</b> (<a class="el" href="classsdsl_1_1int__vector__file__buffer.html">int_vector_file_buffer</a>&lt; 8, size_type_class &gt; &amp;str_buf, typename Csa::size_type len, <a class="el" href="classsdsl_1_1int__vector.html">int_vector</a>&lt; 64 &gt; &amp;C, <a class="el" href="classsdsl_1_1int__vector.html">int_vector</a>&lt; 8 &gt; &amp;char2comp, <a class="el" href="classsdsl_1_1int__vector.html">int_vector</a>&lt; 8 &gt; &amp;comp2char, uint16_t &amp;sigma)</td></tr>
<tr class="memitem:a1f5a7d23431a51b11b1aa1d726d97e09"><td class="memTemplParams" colspan="2">template&lt;class Csa &gt; </td></tr>
<tr class="memitem:a1f5a7d23431a51b11b1aa1d726d97e09"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#a1f5a7d23431a51b11b1aa1d726d97e09">char_occures_in_text_of_csa</a> (const Csa &amp;csa, typename Csa::char_type c)</td></tr>
<tr class="memdesc:a1f5a7d23431a51b11b1aa1d726d97e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates if a character c occures in the text of the compressed suffix array c.  <a href="#a1f5a7d23431a51b11b1aa1d726d97e09"></a><br/></td></tr>
<tr class="memitem:a76cafb0cad4700463ff87245cdb91071"><td class="memTemplParams" colspan="2"><a class="anchor" id="a76cafb0cad4700463ff87245cdb91071"></a>
template&lt;class Csa , uint8_t int_width, class size_type_class &gt; </td></tr>
<tr class="memitem:a76cafb0cad4700463ff87245cdb91071"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_sa_and_isa_samples</b> (<a class="el" href="classsdsl_1_1int__vector__file__buffer.html">int_vector_file_buffer</a>&lt; int_width, size_type_class &gt; &amp;sa_buf, typename Csa::sa_sample_type &amp;sa_sample, typename Csa::isa_sample_type &amp;isa_sample)</td></tr>
<tr class="memitem:a7064dff981abbae3a0c157ad738e7ebd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7064dff981abbae3a0c157ad738e7ebd"></a>
template&lt;class Csa &gt; </td></tr>
<tr class="memitem:a7064dff981abbae3a0c157ad738e7ebd"><td class="memTemplItemLeft" align="right" valign="top">const unsigned char&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ith_character_of_the_first_row</b> (const typename Csa::size_type i, const Csa &amp;csa)</td></tr>
<tr class="memitem:abdad6d5bcd0b3c647a1c96b6e654815e"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessContainer &gt; </td></tr>
<tr class="memitem:abdad6d5bcd0b3c647a1c96b6e654815e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#abdad6d5bcd0b3c647a1c96b6e654815e">construct_supercartesian_tree_bp</a> (const RandomAccessContainer &amp;vec, <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, const bool minimum=true)</td></tr>
<tr class="memdesc:abdad6d5bcd0b3c647a1c96b6e654815e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the balanced parentheses of the Super-Cartesian tree, described in Ohlebusch and Gog (SPIRE 2009).  <a href="#abdad6d5bcd0b3c647a1c96b6e654815e"></a><br/></td></tr>
<tr class="memitem:a125b4aa67a201933291c86dbd99dbc1d"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessContainer &gt; </td></tr>
<tr class="memitem:a125b4aa67a201933291c86dbd99dbc1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#a125b4aa67a201933291c86dbd99dbc1d">construct_supercartesian_tree_bp_succinct</a> (const RandomAccessContainer &amp;vec, <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, const bool minimum=true)</td></tr>
<tr class="memdesc:a125b4aa67a201933291c86dbd99dbc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the balanced parentheses of the Super-Cartesian tree, described in Ohlebusch and Gog (SPIRE 2009).  <a href="#a125b4aa67a201933291c86dbd99dbc1d"></a><br/></td></tr>
<tr class="memitem:a2578e33ee85358c1a0972eac9dcec073"><td class="memTemplParams" colspan="2">template&lt;uint8_t fixedIntWidth, class size_type_class &gt; </td></tr>
<tr class="memitem:a2578e33ee85358c1a0972eac9dcec073"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#a2578e33ee85358c1a0972eac9dcec073">construct_supercartesian_tree_bp_succinct</a> (<a class="el" href="classsdsl_1_1int__vector__file__buffer.html">int_vector_file_buffer</a>&lt; fixedIntWidth, size_type_class &gt; &amp;lcp_buf, <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, const bool minimum=true)</td></tr>
<tr class="memdesc:a2578e33ee85358c1a0972eac9dcec073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the balanced parentheses of the Super-Cartesian tree, described in Ohlebusch and Gog (SPIRE 2009).  <a href="#a2578e33ee85358c1a0972eac9dcec073"></a><br/></td></tr>
<tr class="memitem:adccd0bbfc994289857964dddb81e37b5"><td class="memTemplParams" colspan="2">template&lt;uint8_t fixedIntWidth, class size_type_class &gt; </td></tr>
<tr class="memitem:adccd0bbfc994289857964dddb81e37b5"><td class="memTemplItemLeft" align="right" valign="top">size_type_class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#adccd0bbfc994289857964dddb81e37b5">construct_supercartesian_tree_bp_succinct_and_first_child</a> (<a class="el" href="classsdsl_1_1int__vector__file__buffer.html">int_vector_file_buffer</a>&lt; fixedIntWidth, size_type_class &gt; &amp;lcp_buf, <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp_fc, const bool minimum=true)</td></tr>
<tr class="memdesc:adccd0bbfc994289857964dddb81e37b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the balanced parentheses of the Super-Cartesian tree, described in Ohlebusch and Gog (SPIRE 2009) and the first_child bit_vector.  <a href="#adccd0bbfc994289857964dddb81e37b5"></a><br/></td></tr>
<tr class="memitem:a59238d22fdf7a12ad69767c08f7258f1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a59238d22fdf7a12ad69767c08f7258f1"></a>
template&lt;uint8_t fixedIntWidth, class size_type_class &gt; </td></tr>
<tr class="memitem:a59238d22fdf7a12ad69767c08f7258f1"><td class="memTemplItemLeft" align="right" valign="top">size_type_class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>construct_first_child_lcp</b> (<a class="el" href="classsdsl_1_1int__vector__file__buffer.html">int_vector_file_buffer</a>&lt; fixedIntWidth, size_type_class &gt; &amp;lcp_buf, <a class="el" href="classsdsl_1_1int__vector.html">int_vector</a>&lt; fixedIntWidth, size_type_class &gt; &amp;fc_lcp, size_type_class first_child_size=0)</td></tr>
<tr class="memitem:ace818c90fdcb90fd22d64e5a0fd17eac"><td class="memTemplParams" colspan="2"><a class="anchor" id="ace818c90fdcb90fd22d64e5a0fd17eac"></a>
template&lt;uint32_t SampleDens, uint8_t fixedIntWidth, class size_type_class &gt; </td></tr>
<tr class="memitem:ace818c90fdcb90fd22d64e5a0fd17eac"><td class="memTemplItemLeft" align="right" valign="top">size_type_class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>construct_first_child_and_lf_lcp</b> (<a class="el" href="classsdsl_1_1int__vector__file__buffer.html">int_vector_file_buffer</a>&lt; fixedIntWidth, size_type_class &gt; &amp;lcp_buf, <a class="el" href="classsdsl_1_1int__vector__file__buffer.html">int_vector_file_buffer</a>&lt; 8, size_type_class &gt; &amp;bwt_buf, std::string small_lcp_file_name, std::string big_lcp_file_name, <a class="el" href="classsdsl_1_1int__vector.html">int_vector</a>&lt;&gt; &amp;big_lcp, size_type_class first_child_size=0)</td></tr>
<tr class="memitem:ac7e68133e08fc2256fa684b6a34c7fde"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac7e68133e08fc2256fa684b6a34c7fde"></a>
template&lt;class RandomAccessContainer &gt; </td></tr>
<tr class="memitem:ac7e68133e08fc2256fa684b6a34c7fde"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>construct_supercartesian_tree_bp_succinct2</b> (const RandomAccessContainer &amp;vec, <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, const bool minimum=true)</td></tr>
<tr class="memitem:a90a04937c90c16c5695a54feff817628"><td class="memTemplParams" colspan="2"><a class="anchor" id="a90a04937c90c16c5695a54feff817628"></a>
template&lt;class RandomAccessContainer &gt; </td></tr>
<tr class="memitem:a90a04937c90c16c5695a54feff817628"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessContainer::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>construct_first_p_index</b> (const RandomAccessContainer &amp;vec, <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, const bool minimum=true)</td></tr>
<tr class="memitem:a17d34efeba9403fce858e905f5adf09a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a17d34efeba9403fce858e905f5adf09a"></a>
template&lt;uint8_t fixedIntWidth, class size_type_class &gt; </td></tr>
<tr class="memitem:a17d34efeba9403fce858e905f5adf09a"><td class="memTemplItemLeft" align="right" valign="top">bit_vector::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>construct_first_p_index</b> (<a class="el" href="classsdsl_1_1int__vector__file__buffer.html">int_vector_file_buffer</a>&lt; fixedIntWidth, size_type_class &gt; &amp;lcp_buf, <a class="el" href="namespacesdsl.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;bp, const bool minimum=true)</td></tr>
<tr class="memitem:a18604dbc69c564d1d9a450914b81dff5"><td class="memTemplParams" colspan="2">template&lt;class Cst &gt; </td></tr>
<tr class="memitem:a18604dbc69c564d1d9a450914b81dff5"><td class="memTemplItemLeft" align="right" valign="top">Cst::cst_size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#a18604dbc69c564d1d9a450914b81dff5">forward_search</a> (const Cst &amp;cst, typename Cst::node_type &amp;v, const typename Cst::size_type d, const typename Cst::char_type c, typename Cst::size_type &amp;char_pos)</td></tr>
<tr class="memdesc:a18604dbc69c564d1d9a450914b81dff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward search for a character c on the path on depth <img class="formulaInl" alt="$d$" src="form_45.png"/> to node <img class="formulaInl" alt="$v$" src="form_46.png"/>.  <a href="#a18604dbc69c564d1d9a450914b81dff5"></a><br/></td></tr>
<tr class="memitem:ad28bbdd3c4c78006f82088f54f6a9f6b"><td class="memTemplParams" colspan="2">template&lt;class Cst &gt; </td></tr>
<tr class="memitem:ad28bbdd3c4c78006f82088f54f6a9f6b"><td class="memTemplItemLeft" align="right" valign="top">Cst::cst_size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#ad28bbdd3c4c78006f82088f54f6a9f6b">forward_search</a> (const Cst &amp;cst, typename Cst::node_type &amp;v, typename Cst::size_type d, typename Cst::pattern_type pat, typename Cst::size_type len, typename Cst::size_type &amp;char_pos)</td></tr>
<tr class="memdesc:ad28bbdd3c4c78006f82088f54f6a9f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward search for a pattern pat on the path on depth <img class="formulaInl" alt="$d$" src="form_45.png"/> to node <img class="formulaInl" alt="$v$" src="form_46.png"/>.  <a href="#ad28bbdd3c4c78006f82088f54f6a9f6b"></a><br/></td></tr>
<tr class="memitem:ad32737da7bcd580674970cec72189290"><td class="memTemplParams" colspan="2">template&lt;class Cst &gt; </td></tr>
<tr class="memitem:ad32737da7bcd580674970cec72189290"><td class="memTemplItemLeft" align="right" valign="top">Cst::cst_size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#ad32737da7bcd580674970cec72189290">count</a> (const Cst &amp;cst, typename Cst::pattern_type pat, typename Cst::size_type len)</td></tr>
<tr class="memdesc:ad32737da7bcd580674970cec72189290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the count method for a (compressed) suffix tree of type Cst.  <a href="#ad32737da7bcd580674970cec72189290"></a><br/></td></tr>
<tr class="memitem:aa7ec849d0d160e7040099271ea57fe07"><td class="memTemplParams" colspan="2">template&lt;class Cst , class RandomAccessContainer &gt; </td></tr>
<tr class="memitem:aa7ec849d0d160e7040099271ea57fe07"><td class="memTemplItemLeft" align="right" valign="top">Cst::cst_size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#aa7ec849d0d160e7040099271ea57fe07">locate</a> (const Cst &amp;cst, typename Cst::pattern_type pat, typename Cst::size_type len, RandomAccessContainer &amp;occ)</td></tr>
<tr class="memdesc:aa7ec849d0d160e7040099271ea57fe07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the locate method for a (compressed) suffix tree of type Cst.  <a href="#aa7ec849d0d160e7040099271ea57fe07"></a><br/></td></tr>
<tr class="memitem:aa2551ab7d5920fd3c8c2de8d64e5241a"><td class="memTemplParams" colspan="2">template&lt;class Cst &gt; </td></tr>
<tr class="memitem:aa2551ab7d5920fd3c8c2de8d64e5241a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#aa2551ab7d5920fd3c8c2de8d64e5241a">extract</a> (const Cst &amp;cst, const typename Cst::node_type &amp;v, unsigned char *text)</td></tr>
<tr class="memdesc:aa2551ab7d5920fd3c8c2de8d64e5241a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the concatenation of edge labels from the root to the node v of the (compressed) suffix tree of type Cst.  <a href="#aa2551ab7d5920fd3c8c2de8d64e5241a"></a><br/></td></tr>
<tr class="memitem:a33c46bf53978d11a222aecd6d70c174d"><td class="memTemplParams" colspan="2">template&lt;class Cst &gt; </td></tr>
<tr class="memitem:a33c46bf53978d11a222aecd6d70c174d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesdsl_1_1algorithm.html#a33c46bf53978d11a222aecd6d70c174d">extract</a> (const Cst &amp;cst, const typename Cst::node_type &amp;v)</td></tr>
<tr class="memdesc:a33c46bf53978d11a222aecd6d70c174d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the concatenation of edge labels from the root to the node v of the (compressed) suffix tree of type Cst.  <a href="#a33c46bf53978d11a222aecd6d70c174d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac1683a20ab88ac911379e467ef506f43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1683a20ab88ac911379e467ef506f43"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>near_find_close_8bits_lookup</b> [256]</td></tr>
<tr class="memitem:a281a0ba852714cfa55cbefb6b8365344"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a281a0ba852714cfa55cbefb6b8365344"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>near_find_open_8bits_lookup</b> [256]</td></tr>
<tr class="memitem:a267f8971e6a3ca81032a47ebe8e7d241"><td class="memItemLeft" align="right" valign="top">const int8_t&#160;</td><td class="memItemRight" valign="bottom"><b>excess_8bits_lookup</b> [256]</td></tr>
<tr class="memitem:a0c62b557c63efa282e0ac22dbaf5eb67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c62b557c63efa282e0ac22dbaf5eb67"></a>
const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>near_fwd_excess_8bits_lookup</b> [4352]</td></tr>
<tr class="memitem:a3e61f398315b143c940f5666f5b8d383"><td class="memItemLeft" align="right" valign="top">const int8_t&#160;</td><td class="memItemRight" valign="bottom"><b>near_rmq_8bits_val_lookup</b> [256]</td></tr>
<tr class="memitem:a31d4ca014634d8eaea0c93006e9052fa"><td class="memItemLeft" align="right" valign="top">const int8_t&#160;</td><td class="memItemRight" valign="bottom"><b>near_rightmost_rmq_8bits_pos_lookup</b> [256]</td></tr>
<tr class="memitem:a7c3412dac639b8fc33906ff6fb1e7811"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c3412dac639b8fc33906ff6fb1e7811"></a>
const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>near_bwd_excess_8bits_lookup</b> [4352]</td></tr>
<tr class="memitem:ab616ef5ec17343ab756d86cfb04ff210"><td class="memItemLeft" align="right" valign="top">const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>min_excess_info_8bits_lookup</b> [256]</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A helper class containing algorithms for succinct data structures. </p>
<dl class="section author"><dt>Author:</dt><dd>Simon Gog </dd></dl>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a1a946037a85f7b270054c1765220c18d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class int_vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesdsl_1_1algorithm.html#a1a946037a85f7b270054c1765220c18d">sdsl::algorithm::calculate_enclose</a> </td>
          <td>(</td>
          <td class="paramtype">const bit_vector &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int_vector &amp;&#160;</td>
          <td class="paramname"><em>enclose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates enclose answers for a balanced parentheses sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bp</td><td>A bit_vector representing a balanced parentheses sequence. </td></tr>
    <tr><td class="paramname">enclose</td><td>Reference to the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition:</dt><dd>bp represents a balanced parentheses sequence. </dd></dl>
<dl class="section user"><dt>Time complexity</b></dt><dd><img class="formulaInl" alt="$ \Order{n} $" src="form_18.png"/>, where <img class="formulaInl" alt="$ n=$" src="form_16.png"/>bp.size() </dd></dl>
<dl class="section user"><dt>Space complexity</b></dt><dd><img class="formulaInl" alt="$ \Order{n + 2n\log n } $" src="form_21.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="ab7dd2a643b582a46ef854f91c7b5534a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class int_vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesdsl_1_1algorithm.html#ab7dd2a643b582a46ef854f91c7b5534a">sdsl::algorithm::calculate_matches</a> </td>
          <td>(</td>
          <td class="paramtype">const bit_vector &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int_vector &amp;&#160;</td>
          <td class="paramname"><em>matches</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates matches (i.e. find_open for a closing parenthesis and find_close for an opening parenthesis) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bp</td><td>A bit_vector representing a balanced parentheses sequence. </td></tr>
    <tr><td class="paramname">matches</td><td>Reference to the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition:</dt><dd>bp represents a balanced parentheses sequence. </dd></dl>
<dl class="section user"><dt>Time complexity</b></dt><dd><img class="formulaInl" alt="$ \Order{n} $" src="form_18.png"/>, where <img class="formulaInl" alt="$ n=$" src="form_16.png"/>bp.size() </dd></dl>
<dl class="section user"><dt>Space complexity</b></dt><dd><img class="formulaInl" alt="$ \Order{n + 2n\log n } $" src="form_21.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="aad3d575e4af846500969776005d27db1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesdsl_1_1algorithm.html#aad3d575e4af846500969776005d27db1">sdsl::algorithm::calculate_pioneers_bitmap</a> </td>
          <td>(</td>
          <td class="paramtype">const bit_vector &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_vector::size_type&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_vector &amp;&#160;</td>
          <td class="paramname"><em>pioneer_bitmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate pioneers as defined in the paper of Geary et al. (CPM 2004) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bp</td><td>The balanced parentheses sequence for that the pioneers should be calculated. </td></tr>
    <tr><td class="paramname">block_size</td><td>Size of the blocks for which the pioneers should be calculated. </td></tr>
    <tr><td class="paramname">pioneer_bitmap</td><td>Reference to the resulting bit_vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</b></dt><dd><img class="formulaInl" alt="$ \Order{n \log n} $" src="form_15.png"/>, where <img class="formulaInl" alt="$ n=$" src="form_16.png"/>bp.size() </dd></dl>
<dl class="section user"><dt>Space complexity</b></dt><dd><img class="formulaInl" alt="$ \Order{2n + min(block\_size, \frac{n}{block\_size} )\cdot \log n } $" src="form_17.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="acb1eb31bc30f95a024b84b7cc4cad60f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class size_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesdsl_1_1algorithm.html#acb1eb31bc30f95a024b84b7cc4cad60f">sdsl::algorithm::calculate_pioneers_bitmap_succinct</a> </td>
          <td>(</td>
          <td class="paramtype">const bit_vector &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_vector &amp;&#160;</td>
          <td class="paramname"><em>pioneer_bitmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate pioneers as defined in the paper of Geary et al. (CPM 2004) with few extra space. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bp</td><td>The balanced parentheses sequence for that the pioneers should be calculated. </td></tr>
    <tr><td class="paramname">block_size</td><td>Size of the blocks for which the pioneers should be calculated. </td></tr>
    <tr><td class="paramname">pioneer_bitmap</td><td>Reference to the resulting bit_vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</b></dt><dd><img class="formulaInl" alt="$ \Order{n} $" src="form_18.png"/>, where <img class="formulaInl" alt="$ n=$" src="form_16.png"/>bp.size() </dd></dl>
<dl class="section user"><dt>Space complexity</b></dt><dd><img class="formulaInl" alt="$ \Order{2n + n} $" src="form_19.png"/> bits: <img class="formulaInl" alt="$n$" src="form_20.png"/> bits for input, <img class="formulaInl" alt="$n$" src="form_20.png"/> bits for output, and <img class="formulaInl" alt="$n$" src="form_20.png"/> bits for a succinct stack. </dd></dl>
<dl class="section pre"><dt>Precondition:</dt><dd>The parentheses sequence represented by bp has to be balanced. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b56b5bd8cfa769ca13436a3615cc5ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessContainer1 , class RandomAccessContainer2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesdsl_1_1algorithm.html#a4b56b5bd8cfa769ca13436a3615cc5ae">sdsl::algorithm::calculate_psv</a> </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessContainer1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessContainer2 &amp;&#160;</td>
          <td class="paramname"><em>psv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the previous smaller value (psv) array for a random access container a. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Container to calculate the psv array. </td></tr>
    <tr><td class="paramname">psv</td><td>Container that contains the result after the calculation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition:</dt><dd>The array <em>a</em> contains only non negative values and a.size() == psv.size(). </dd></dl>
<dl class="section post"><dt>Postcondition:</dt><dd><p class="formulaDsp">
<img class="formulaDsp" alt="\[ psv[i] = \begin{array}{rl} a.size() &amp;\mbox{ if} \min\{ a[j] \mid j<i \} \geq a[i] \\ max\{j\mid a[j] < a[i] \wedge j<i\} &amp;\mbox{ otherwise.}\end{array} \]" src="form_3.png"/>
</p>
 </dd></dl>

</div>
</div>
<a class="anchor" id="a1f5a7d23431a51b11b1aa1d726d97e09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacesdsl_1_1algorithm.html#a1f5a7d23431a51b11b1aa1d726d97e09">sdsl::algorithm::char_occures_in_text_of_csa</a> </td>
          <td>(</td>
          <td class="paramtype">const Csa &amp;&#160;</td>
          <td class="paramname"><em>csa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Csa::char_type&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates if a character c occures in the text of the compressed suffix array c. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">csa</td><td>The csa in which we search for the occurence of c. </td></tr>
    <tr><td class="paramname">c</td><td>The character c for which we search in the text of the compressed suffix array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>True, if c occures in the text of the compressed suffix array and False otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition:</dt><dd><img class="formulaInl" alt="$ csa.size()>0 $" src="form_26.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="abdad6d5bcd0b3c647a1c96b6e654815e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesdsl_1_1algorithm.html#abdad6d5bcd0b3c647a1c96b6e654815e">sdsl::algorithm::construct_supercartesian_tree_bp</a> </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessContainer &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_vector &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>minimum</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the balanced parentheses of the Super-Cartesian tree, described in Ohlebusch and Gog (SPIRE 2009). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>Random access container for which the Super-Cartesian tree representation should be calculated. The value_type of vec should be an unsigned integer type. </td></tr>
    <tr><td class="paramname">bp</td><td>Reference to the balanced parentheses sequence which represents the Super-Cartesian tree. </td></tr>
    <tr><td class="paramname">minimum</td><td>Specifies if the higher levels contains minima or maxima. Default is maxima. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</b></dt><dd><img class="formulaInl" alt="$ \Order{2n} $" src="form_27.png"/>, where <img class="formulaInl" alt="$ n=$" src="form_16.png"/>vec.size() </dd></dl>
<dl class="section user"><dt>Space complexity</b></dt><dd><img class="formulaInl" alt="$ \Order{n \cdot \log n } $" src="form_28.png"/> bits. </dd></dl>

</div>
</div>
<a class="anchor" id="a125b4aa67a201933291c86dbd99dbc1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesdsl_1_1algorithm.html#a125b4aa67a201933291c86dbd99dbc1d">sdsl::algorithm::construct_supercartesian_tree_bp_succinct</a> </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessContainer &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_vector &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>minimum</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the balanced parentheses of the Super-Cartesian tree, described in Ohlebusch and Gog (SPIRE 2009). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>Random access container for which the Super-Cartesian tree representation should be calculated. The value_type of vec should be an unsigned integer type. </td></tr>
    <tr><td class="paramname">bp</td><td>Reference to the balanced parentheses sequence which represents the Super-Cartesian tree. </td></tr>
    <tr><td class="paramname">minimum</td><td>Specifies if the higher levels contains minima or maxima. Default is maxima. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</b></dt><dd><img class="formulaInl" alt="$ \Order{2n} $" src="form_27.png"/>, where <img class="formulaInl" alt="$ n=$" src="form_16.png"/>vec.size() </dd></dl>
<dl class="section user"><dt>Space complexity</b></dt><dd><img class="formulaInl" alt="$\Order{n}$" src="form_29.png"/> bits, by the stack_support described in the paper "Optimal Succinctness For Range Minimum Queries" of Johannes Fischer. </dd></dl>

</div>
</div>
<a class="anchor" id="a2578e33ee85358c1a0972eac9dcec073"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t fixedIntWidth, class size_type_class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesdsl_1_1algorithm.html#a125b4aa67a201933291c86dbd99dbc1d">sdsl::algorithm::construct_supercartesian_tree_bp_succinct</a> </td>
          <td>(</td>
          <td class="paramtype">int_vector_file_buffer&lt; fixedIntWidth, size_type_class &gt; &amp;&#160;</td>
          <td class="paramname"><em>lcp_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_vector &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>minimum</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the balanced parentheses of the Super-Cartesian tree, described in Ohlebusch and Gog (SPIRE 2009). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lcp_buf</td><td><a class="el" href="classsdsl_1_1int__vector__file__buffer.html" title="A class for reading an int_vector buffered from a file.">int_vector_file_buffer</a> of the LCP Array for which the Super-Cartesian tree representation should be calculated. The value_type of vec should be an unsigned integer type. </td></tr>
    <tr><td class="paramname">bp</td><td>Reference to the balanced parentheses sequence which represents the Super-Cartesian tree. </td></tr>
    <tr><td class="paramname">minimum</td><td>Specifies if the higher levels contains minima or maxima. Default is maxima. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</b></dt><dd><img class="formulaInl" alt="$ \Order{2n} $" src="form_27.png"/>, where <img class="formulaInl" alt="$ n=$" src="form_16.png"/>vec.size() </dd></dl>
<dl class="section user"><dt>Space complexity</b></dt><dd><img class="formulaInl" alt="$\Order{2n}$" src="form_30.png"/> bits, by the multi_stack_support </dd></dl>

</div>
</div>
<a class="anchor" id="adccd0bbfc994289857964dddb81e37b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t fixedIntWidth, class size_type_class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type_class <a class="el" href="namespacesdsl_1_1algorithm.html#adccd0bbfc994289857964dddb81e37b5">sdsl::algorithm::construct_supercartesian_tree_bp_succinct_and_first_child</a> </td>
          <td>(</td>
          <td class="paramtype">int_vector_file_buffer&lt; fixedIntWidth, size_type_class &gt; &amp;&#160;</td>
          <td class="paramname"><em>lcp_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_vector &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_vector &amp;&#160;</td>
          <td class="paramname"><em>bp_fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>minimum</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the balanced parentheses of the Super-Cartesian tree, described in Ohlebusch and Gog (SPIRE 2009) and the first_child bit_vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lcp_buf</td><td><a class="el" href="classsdsl_1_1int__vector__file__buffer.html" title="A class for reading an int_vector buffered from a file.">int_vector_file_buffer</a> for the lcp array for which the Super-Cartesian tree representation should be calculated. The value_type of vec should be an unsigned integer type. </td></tr>
    <tr><td class="paramname">bp</td><td>Reference to the balanced parentheses sequence which represents the Super-Cartesian tree. </td></tr>
    <tr><td class="paramname">bp_fc</td><td>Reference to the first child bit_vector of bp. </td></tr>
    <tr><td class="paramname">minimum</td><td>Specifies if the higher levels contains minima or maxima. Default is maxima. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</b></dt><dd><img class="formulaInl" alt="$ \Order{2n} $" src="form_27.png"/>, where <img class="formulaInl" alt="$ n=$" src="form_16.png"/>vec.size() </dd></dl>
<dl class="section user"><dt>Space complexity</b></dt><dd><img class="formulaInl" alt="$\Order{2n}$" src="form_30.png"/> bits, by the multi_stack_support </dd></dl>

</div>
</div>
<a class="anchor" id="ad32737da7bcd580674970cec72189290"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Cst::cst_size_type sdsl::algorithm::count </td>
          <td>(</td>
          <td class="paramtype">const Cst &amp;&#160;</td>
          <td class="paramname"><em>cst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::pattern_type&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::size_type&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the count method for a (compressed) suffix tree of type Cst. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cst</td><td>A const reference to the (compressed) suffix tree. </td></tr>
    <tr><td class="paramname">pat</td><td>The pattern we seach the number of occurences. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the pattern. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>Number of occurences of the pattern in the text of the (compressed) suffix tree. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2551ab7d5920fd3c8c2de8d64e5241a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sdsl::algorithm::extract </td>
          <td>(</td>
          <td class="paramtype">const Cst &amp;&#160;</td>
          <td class="paramname"><em>cst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Cst::node_type &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the concatenation of edge labels from the root to the node v of the (compressed) suffix tree of type Cst. </p>
<div class="fragment"><pre class="fragment"> \param cst A const reference to the compressed suffix tree.
 \param v The node where the concatenation of the edge labels ends.
 \param text A pointer in which the string representing the concatenation of edge labels form the root to the node v will be stored.
</pre></div> <dl class="section pre"><dt>Precondition:</dt><dd>text has to be initialized with enough memory ( <img class="formulaInl" alt="$ cst.depth(v)+1$" src="form_49.png"/> bytes) to hold the extracted text. </dd></dl>

</div>
</div>
<a class="anchor" id="a33c46bf53978d11a222aecd6d70c174d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string sdsl::algorithm::extract </td>
          <td>(</td>
          <td class="paramtype">const Cst &amp;&#160;</td>
          <td class="paramname"><em>cst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Cst::node_type &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the concatenation of edge labels from the root to the node v of the (compressed) suffix tree of type Cst. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cst</td><td>A const reference to the compressed suffix tree. </td></tr>
    <tr><td class="paramname">v</td><td>The node where the concatenation of the edge labels ends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The string of the concatenated edge labels from the root to the node v. </dd></dl>

</div>
</div>
<a class="anchor" id="a18604dbc69c564d1d9a450914b81dff5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Cst::cst_size_type <a class="el" href="namespacesdsl_1_1algorithm.html#a18604dbc69c564d1d9a450914b81dff5">sdsl::algorithm::forward_search</a> </td>
          <td>(</td>
          <td class="paramtype">const Cst &amp;&#160;</td>
          <td class="paramname"><em>cst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::node_type &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Cst::size_type&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Cst::char_type&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::size_type &amp;&#160;</td>
          <td class="paramname"><em>char_pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Forward search for a character c on the path on depth <img class="formulaInl" alt="$d$" src="form_45.png"/> to node <img class="formulaInl" alt="$v$" src="form_46.png"/>. </p>
<div class="fragment"><pre class="fragment">   \param cst              The compressed suffix tree.
   \param v                The node at the endpoint of the current edge.
   \param d                The current depth of the path. 0 = first character on each edge of the root node.
   \param c                The character c which should be matched at the path on depth \form#45 to node \form#46.
   \param char_pos One position in the text, which corresponds to the text that is already matched. If v=cst.root() and d=0 =&gt; char_pos=0.

   \par Time complexity
</pre></div><p> <img class="formulaInl" alt="$ \Order{ t_{\Psi} } $" src="form_47.png"/> or <img class="formulaInl" alt="$ \Order{t_{cst.child}} $" src="form_48.png"/> </p>

</div>
</div>
<a class="anchor" id="ad28bbdd3c4c78006f82088f54f6a9f6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Cst::cst_size_type <a class="el" href="namespacesdsl_1_1algorithm.html#a18604dbc69c564d1d9a450914b81dff5">sdsl::algorithm::forward_search</a> </td>
          <td>(</td>
          <td class="paramtype">const Cst &amp;&#160;</td>
          <td class="paramname"><em>cst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::node_type &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::size_type&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::pattern_type&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::size_type&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::size_type &amp;&#160;</td>
          <td class="paramname"><em>char_pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Forward search for a pattern pat on the path on depth <img class="formulaInl" alt="$d$" src="form_45.png"/> to node <img class="formulaInl" alt="$v$" src="form_46.png"/>. </p>
<div class="fragment"><pre class="fragment">   \param cst              The compressed suffix tree.
   \param v                The node at the endpoint of the current edge.
   \param d                The current depth of the path. 0 = first character on each edge of the root node.
   \param pat      The character c which should be matched at the path on depth \form#45 to node \form#46.
   \param len              The length of the pattern.
   \param char_pos One position in the text, which corresponds to the text that is already matched. If v=cst.root() and d=0 =&gt; char_pos=0.

   \par Time complexity
</pre></div><p> <img class="formulaInl" alt="$ \Order{ t_{\Psi} } $" src="form_47.png"/> or <img class="formulaInl" alt="$ \Order{t_{cst.child}} $" src="form_48.png"/> </p>

</div>
</div>
<a class="anchor" id="a38f909df0f34bec09d2e59a4fdea52f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespacesdsl_1_1algorithm.html#a38f909df0f34bec09d2e59a4fdea52f1">sdsl::algorithm::H_0</a> </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the zero-order entropy for a text T. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Pointer to a 0-terminated string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The zero-order entropy of the text. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7ec849d0d160e7040099271ea57fe07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cst , class RandomAccessContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Cst::cst_size_type sdsl::algorithm::locate </td>
          <td>(</td>
          <td class="paramtype">const Cst &amp;&#160;</td>
          <td class="paramname"><em>cst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::pattern_type&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::size_type&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessContainer &amp;&#160;</td>
          <td class="paramname"><em>occ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the locate method for a (compressed) suffix tree of type Cst. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cst</td><td>A const reference to the (compressed) suffix tree. </td></tr>
    <tr><td class="paramname">pat</td><td>The pattern for which we seach the occurences for. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the pattern. </td></tr>
    <tr><td class="paramname">occ</td><td>A reference to a random access container in which we store the occurences of pattern in the text of the (compressed suffix array). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>Number of occurences of the pattern in the text of the (compressed) suffix tree. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d6c53e2e8f22a71de82750d8f472cb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bit_vector::size_type <a class="el" href="namespacesdsl_1_1algorithm.html#a1d6c53e2e8f22a71de82750d8f472cb2">sdsl::algorithm::near_bwd_excess</a> </td>
          <td>(</td>
          <td class="paramtype">const bit_vector &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_vector::size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_vector::difference_type&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bit_vector::size_type&#160;</td>
          <td class="paramname"><em>block_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method searches the maximal parenthesis j, with <img class="formulaInl" alt="$ j\leq i $" src="form_23.png"/>, such that <img class="formulaInl" alt="$ excess(j) = excess(i+1)+rel $" src="form_24.png"/> and. </p>
<p>i &lt; bp.size()-1 </p>

</div>
</div>
<a class="anchor" id="a88e65161b14a1a12aebeddc9cf0300f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bit_vector::size_type <a class="el" href="namespacesdsl_1_1algorithm.html#a88e65161b14a1a12aebeddc9cf0300f2">sdsl::algorithm::near_enclose</a> </td>
          <td>(</td>
          <td class="paramtype">const bit_vector &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_vector::size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bit_vector::size_type&#160;</td>
          <td class="paramname"><em>block_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the opening parenthesis of the enclosing pair if this parenthesis is near. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bp</td><td>bit_vector containing the representation of the balanced parentheses sequence. </td></tr>
    <tr><td class="paramname">i</td><td>Position of the opening parenthesis for which we search the position of the opening parenthesis of the enclosing parentheses pair. </td></tr>
    <tr><td class="paramname">block_size</td><td>Number of entries to search for the corresponding opening parenthesis of the enclosing parentheses pair. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>If no near enclose exists return i, otherwise the position of the opening parenthesis of the enclosing pair. </dd></dl>
<dl class="section pre"><dt>Precondition:</dt><dd>We assert that <img class="formulaInl" alt="$ bp[i]=1 $" src="form_22.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="a2784d01a7b9c1fa332e1278b246ccc68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bit_vector::size_type <a class="el" href="namespacesdsl_1_1algorithm.html#a2784d01a7b9c1fa332e1278b246ccc68">sdsl::algorithm::near_find_close_naive</a> </td>
          <td>(</td>
          <td class="paramtype">const bit_vector &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_vector::size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bit_vector::size_type&#160;</td>
          <td class="paramname"><em>block_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the near closing parenthesis if it exists. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bp</td><td>bit_vector containing the representation of the balanced parentheses sequence. </td></tr>
    <tr><td class="paramname">i</td><td>Position of the opening parenthesis we for which search the corresponding closing parenthesis. </td></tr>
    <tr><td class="paramname">block_size</td><td>Number of entries to search for the corresponding closing parenthesis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>i if there is no near find_close answer, otherwise the position of the near closing parenthesis. </dd></dl>
<dl class="section pre"><dt>Precondition:</dt><dd>We assert that <img class="formulaInl" alt="$ bp[i]=1 $" src="form_22.png"/> holds, i.e. there is an opening parenthesis at position i. </dd></dl>

</div>
</div>
<a class="anchor" id="aa17028f3a5eec3834f1d1b86415eb48f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bit_vector::size_type <a class="el" href="namespacesdsl_1_1algorithm.html#aa17028f3a5eec3834f1d1b86415eb48f">sdsl::algorithm::near_find_open_naive</a> </td>
          <td>(</td>
          <td class="paramtype">const bit_vector &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_vector::size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bit_vector::size_type&#160;</td>
          <td class="paramname"><em>block_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the near opening parenthesis if it exists. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bp</td><td>bit_vector containing the representation of the balanced parentheses sequence. </td></tr>
    <tr><td class="paramname">i</td><td>Position of the closing parenthesis for which we search the corresponding opening parenthesis. </td></tr>
    <tr><td class="paramname">block_size</td><td>Number of entries to search for the corresponding opening parenthesis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>i if there is no near opening parenthesis, otherwise the position of the near opening parenthesis. </dd></dl>
<dl class="section pre"><dt>Precondition:</dt><dd>We assert that <img class="formulaInl" alt="$ bp[i]=0 $" src="form_25.png"/> holds, i.e. there is an closing parenthesis at position i. </dd></dl>

</div>
</div>
<a class="anchor" id="a772cc32d6b1183bc7879d1e399c9758e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bit_vector::size_type <a class="el" href="namespacesdsl_1_1algorithm.html#a772cc32d6b1183bc7879d1e399c9758e">sdsl::algorithm::near_fwd_excess</a> </td>
          <td>(</td>
          <td class="paramtype">const bit_vector &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_vector::size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_vector::difference_type&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bit_vector::size_type&#160;</td>
          <td class="paramname"><em>block_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method searches the minimal parenthesis j, with j&gt;=i, such that excess(j) = excess(i-1)+rel. </p>
<p>i&gt;0 </p>

</div>
</div>
<a class="anchor" id="a1330e14ac6487679fc85942a188d8e34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bit_vector::size_type <a class="el" href="namespacesdsl_1_1algorithm.html#a1330e14ac6487679fc85942a188d8e34">sdsl::algorithm::near_rmq</a> </td>
          <td>(</td>
          <td class="paramtype">const bit_vector &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_vector::size_type&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_vector::size_type&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_vector::difference_type &amp;&#160;</td>
          <td class="paramname"><em>min_rel_ex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the position with minimal excess value in the interval [l..r]. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bp</td><td>The bit_vector which represents the parentheses sequence </td></tr>
    <tr><td class="paramname">l</td><td>The left border of the interval. </td></tr>
    <tr><td class="paramname">r</td><td>The right border of the interval. </td></tr>
    <tr><td class="paramname">min_rel_ex</td><td>Reference to the relative minimal excess value with regards to excess(bp[l]) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a267f8971e6a3ca81032a47ebe8e7d241"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int8_t sdsl::algorithm::excess_8bits_lookup[256]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
    -8,-6,-6,-4,-6,-4,-4,-2,-6,-4,-4,-2,-4,-2,-2,0,
    -6,-4,-4,-2,-4,-2,-2,0,-4,-2,-2,0,-2,0,0,2,
    -6,-4,-4,-2,-4,-2,-2,0,-4,-2,-2,0,-2,0,0,2,
    -4,-2,-2,0,-2,0,0,2,-2,0,0,2,0,2,2,4,
    -6,-4,-4,-2,-4,-2,-2,0,-4,-2,-2,0,-2,0,0,2,
    -4,-2,-2,0,-2,0,0,2,-2,0,0,2,0,2,2,4,
    -4,-2,-2,0,-2,0,0,2,-2,0,0,2,0,2,2,4,
    -2,0,0,2,0,2,2,4,0,2,2,4,2,4,4,6,
    -6,-4,-4,-2,-4,-2,-2,0,-4,-2,-2,0,-2,0,0,2,
    -4,-2,-2,0,-2,0,0,2,-2,0,0,2,0,2,2,4,
    -4,-2,-2,0,-2,0,0,2,-2,0,0,2,0,2,2,4,
    -2,0,0,2,0,2,2,4,0,2,2,4,2,4,4,6,
    -4,-2,-2,0,-2,0,0,2,-2,0,0,2,0,2,2,4,
    -2,0,0,2,0,2,2,4,0,2,2,4,2,4,4,6,
    -2,0,0,2,0,2,2,4,0,2,2,4,2,4,4,6,
    0,2,2,4,2,4,4,6,2,4,4,6,4,6,6,8
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab616ef5ec17343ab756d86cfb04ff210"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t sdsl::algorithm::min_excess_info_8bits_lookup[256]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
    17,4105,4360,8201,4615,8713,8456,12297,4870,8968,8968,12297,8711,12809,12552,16393,
    5125,9223,9223,13321,9223,13321,12552,16393,8966,13064,13064,16393,12807,16905,16648,20489,
    5380,9478,9478,13576,9478,13576,13576,16393,9478,13576,13576,16393,12807,16905,16648,20489,
    9221,13319,13319,17417,13319,17417,16648,20489,13062,17160,17160,20489,16903,21001,20744,24585,
    5635,9733,9733,13831,9733,13831,13831,17929,9733,13831,13831,17929,13831,17929,16648,20489,
    9733,13831,13831,17929,13831,17929,16648,20489,13062,17160,17160,20489,16903,21001,20744,24585,
    9476,13574,13574,17672,13574,17672,17672,20489,13574,17672,17672,20489,16903,21001,20744,24585,
    13317,17415,17415,21513,17415,21513,20744,24585,17158,21256,21256,24585,20999,25097,24840,28681,
    5890,9988,9988,14086,9988,14086,14086,18184,9988,14086,14086,18184,14086,18184,18184,20489,
    9988,14086,14086,18184,14086,18184,18184,20489,14086,18184,18184,20489,16903,21001,20744,24585,
    9988,14086,14086,18184,14086,18184,18184,20489,14086,18184,18184,20489,16903,21001,20744,24585,
    13317,17415,17415,21513,17415,21513,20744,24585,17158,21256,21256,24585,20999,25097,24840,28681,
    9731,13829,13829,17927,13829,17927,17927,22025,13829,17927,17927,22025,17927,22025,20744,24585,
    13829,17927,17927,22025,17927,22025,20744,24585,17158,21256,21256,24585,20999,25097,24840,28681,
    13572,17670,17670,21768,17670,21768,21768,24585,17670,21768,21768,24585,20999,25097,24840,28681,
    17413,21511,21511,25609,21511,25609,24840,28681,21254,25352,25352,28681,25095,29193,28936,32777
}
</pre></div>
</div>
</div>
<a class="anchor" id="a31d4ca014634d8eaea0c93006e9052fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int8_t sdsl::algorithm::near_rightmost_rmq_8bits_pos_lookup[256]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,
    7,7,7,7,7,7,0,0,2,2,2,2,1,1,0,0,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,
    7,7,7,7,7,7,0,0,2,2,2,2,1,1,0,0,
    4,4,4,4,4,4,4,4,4,4,4,4,1,1,0,0,
    3,3,3,3,3,3,0,0,2,2,2,2,1,1,0,0,
    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
    6,6,6,6,6,6,6,6,6,6,6,6,1,1,0,0,
    6,6,6,6,6,6,6,6,6,6,6,6,1,1,0,0,
    3,3,3,3,3,3,0,0,2,2,2,2,1,1,0,0,
    5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,
    5,5,5,5,5,5,0,0,2,2,2,2,1,1,0,0,
    4,4,4,4,4,4,4,4,4,4,4,4,1,1,0,0,
    3,3,3,3,3,3,0,0,2,2,2,2,1,1,0,0
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3e61f398315b143c940f5666f5b8d383"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int8_t sdsl::algorithm::near_rmq_8bits_val_lookup[256]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
    -8,-6,-6,-4,-6,-4,-4,-2,-6,-4,-4,-2,-4,-2,-2,0,
    -6,-4,-4,-2,-4,-2,-2,0,-4,-2,-2,0,-2,0,-1,1,
    -6,-4,-4,-2,-4,-2,-2,0,-4,-2,-2,0,-2,0,-1,1,
    -4,-2,-2,0,-2,0,-1,1,-3,-1,-1,1,-2,0,-1,1,
    -6,-4,-4,-2,-4,-2,-2,0,-4,-2,-2,0,-2,0,-1,1,
    -4,-2,-2,0,-2,0,-1,1,-3,-1,-1,1,-2,0,-1,1,
    -5,-3,-3,-1,-3,-1,-1,1,-3,-1,-1,1,-2,0,-1,1,
    -4,-2,-2,0,-2,0,-1,1,-3,-1,-1,1,-2,0,-1,1,
    -7,-5,-5,-3,-5,-3,-3,-1,-5,-3,-3,-1,-3,-1,-1,1,
    -5,-3,-3,-1,-3,-1,-1,1,-3,-1,-1,1,-2,0,-1,1,
    -5,-3,-3,-1,-3,-1,-1,1,-3,-1,-1,1,-2,0,-1,1,
    -4,-2,-2,0,-2,0,-1,1,-3,-1,-1,1,-2,0,-1,1,
    -6,-4,-4,-2,-4,-2,-2,0,-4,-2,-2,0,-2,0,-1,1,
    -4,-2,-2,0,-2,0,-1,1,-3,-1,-1,1,-2,0,-1,1,
    -5,-3,-3,-1,-3,-1,-1,1,-3,-1,-1,1,-2,0,-1,1,
    -4,-2,-2,0,-2,0,-1,1,-3,-1,-1,1,-2,0,-1,1
}
</pre></div>
</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 13 2012 14:05:51 for SDSL: Succinct Data Structure Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
