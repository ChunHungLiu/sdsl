<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>SDSL: Succinct Data Structure Library: sdsl Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">SDSL: Succinct Data Structure Library
   
   </div>
   <div id="projectbrief">A C++ template library for succinct data structures</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sdsl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for the succinct data structure library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:a00286"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00286.html">algorithm</a></td></tr>
<tr class="memdesc:a00286"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class containing algorithms for succinct data structures. <br/></td></tr>
<tr class="memitem:a00287"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00287.html">coder</a></td></tr>
<tr class="memdesc:a00287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for the different coder of the sdsl. <br/></td></tr>
<tr class="memitem:a00288"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00288.html">util</a></td></tr>
<tr class="memdesc:a00288"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace for helper functions. <br/></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html">bit_vector_interleaved</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bit vector which interleaves the original bit_vector with rank information.  <a href="a00016.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html">rank_support_interleaved</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00145.html">select_support_interleaved</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html">bit_magic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for bitwise tricks on 64 bit words.  <a href="a00015.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html">bp_support_g</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that provides support for bit_vectors that represent a balanced parentheses sequence. Implementation was proposed by Geary et al. (CPM 2004) and extended by Ohlebusch and Gog (SPIRE 2009).  <a href="a00019.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html">bp_support_gg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that provides support for bit_vectors that represent a balanced parentheses sequence. Implementation was proposed by Geary et al. (CPM 2004) and extended by Ohlebusch and Gog (SPIRE 2009).  <a href="a00020.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html">bp_support_j</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that provides support for bit_vectors that represent a balanced parentheses sequence. Implementation was proposed by Jacobson (1989) and Geary et al. (CPM 2004).  <a href="a00021.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html">bp_support_sada</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that provides support for bit_vectors that represent a balanced parentheses sequence. Implementation was proposed by Kunihiko Sadakane in the paper "The Ultimate Balanced Parentheses" (Technical Report 2008).  <a href="a00022.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html">csa_sada_trait</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00031.html">csa_sada_trait&lt; 32 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00032.html">csa_sada_trait&lt; 64 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00028.html">csa_sada</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the Compressed Suffix Array (CSA) proposed by Sadakane for practical implementation.  <a href="a00028.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html">csa_sada_theo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the Compressed Suffix Array (CSA) proposed by Sadakane. <a class="el" href="a00029.html" title="A class for the Compressed Suffix Array (CSA) proposed by Sadakane. csa_sada_theo is the one to one i...">csa_sada_theo</a> is the one to one implementation of Sadakane's theoretical description with our data structures.  <a href="a00029.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00034.html">csa_uncompressed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the uncmpressed suffix array (SA).  <a href="a00034.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html">csa_wt_trait</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html">csa_wt_trait&lt; 32 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00038.html">csa_wt_trait&lt; 64 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html">psi_of_csa_wt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper class for the <img class="formulaInl" alt="$\Psi$" src="form_6.png"/> and LF function for (compressed) suffix arrays that are based on a wavelet tree (like <a class="el" href="a00035.html" title="A class for the Compressed Suffix Array (CSA) based on a Wavelet Tree (WT) of the Burrow Wheeler Tran...">sdsl::csa_wt</a>).  <a href="a00109.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00025.html">bwt_of_csa_wt</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">csa_wt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the Compressed Suffix Array (CSA) based on a Wavelet Tree (WT) of the Burrow Wheeler Transform of the orignal text.  <a href="a00035.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00018.html">bp_interval_p</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00046.html">cst_sct3p</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.  <a href="a00046.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html">cst_dfs_const_forward_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An forward iterator for (compressed) suffix trees.  <a href="a00041.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">cst_bottom_up_const_forward_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator for a bottom up traversal of a suffix tree.  <a href="a00040.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00039.html">cst_bfs_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator for a breath first traversal of a tree.  <a href="a00039.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00042.html">cst_sada</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the Compressed Suffix Tree (CST) proposed by Sadakane.  <a href="a00042.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00089.html">lcp_interval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct for the representation of an lcp-interval <img class="formulaInl" alt="$\ell-[left..right]$" src="form_144.png"/>.  <a href="a00089.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00043.html">cst_sct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.  <a href="a00043.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html">cst_sct2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.  <a href="a00044.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html">bp_interval</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html">cst_sct3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.  <a href="a00045.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00060.html">enc_vector_trait</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html">enc_vector_trait&lt; 32 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00049.html">enc_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic immutable space-saving vector class for unsigned integers. It encodes each integer with its self-delimiting code and still provides constant time access.  <a href="a00049.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00051.html">enc_vector_dna_trait</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html">enc_vector_dna_trait&lt; 32 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html">enc_vector_dna</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An immutable space-saving vector class for unsigned positiv integers of the psi-values of dna data.  <a href="a00050.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html">enc_vector_prac2_trait</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html">enc_vector_prac2_trait&lt; 32 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html">enc_vector_prac2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic immutable space-saving vector class for unsigned positiv integers. It encodes each integer with its self-delimiting code and still provides constant time access.  <a href="a00053.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00058.html">enc_vector_theo_trait</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00059.html">enc_vector_theo_trait&lt; 32 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00056.html">enc_vector_theo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic immutable space-saving vector class for unsigned integers. It encodes each integer with its self-delimiting code and still provides constant time access.  <a href="a00056.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html">enc_vector_theo_const_iterator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html">fast_cache</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00067.html">gap_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bit vector which compresses very sparse populated bit vectors by representing the 1 or 0 by gap encoding.  <a href="a00067.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00065.html">gap_rank_support</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00066.html">gap_select_support</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html">int_vector_trait</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html">int_vector_trait&lt; 64, size_type_class &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00084.html">int_vector_trait&lt; 32, size_type_class &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00083.html">int_vector_trait&lt; 16, size_type_class &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html">int_vector_trait&lt; 8, size_type_class &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html">int_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic vector class for integers of width <img class="formulaInl" alt="$w\in [1..64]$" src="form_173.png"/>.  <a href="a00068.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html">int_vector_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy class that acts as a reference to an integer of length <code>len</code> bits in a <a class="el" href="a00068.html" title="A generic vector class for integers of width .">int_vector</a>.  <a href="a00076.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html">int_vector_reference&lt; bit_vector &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00072.html">int_vector_iterator_base</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html">int_vector_iterator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html">int_vector_const_iterator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html">char_array_serialize_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper class which allows us to serialize an char array as an <a class="el" href="a00068.html" title="A generic vector class for integers of width .">int_vector</a>.  <a href="a00026.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html">int_vector_file_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for reading an <a class="el" href="a00068.html" title="A generic vector class for integers of width .">int_vector</a> buffered from a file.  <a href="a00070.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html">int_vector_serialize_vbyte_wrapper</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html">int_vector_load_vbyte_wrapper</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html">int_vector_serialize_vlen_wrapper</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00074.html">int_vector_load_vlen_wrapper</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html">int_vector_serialize_wrapper</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00075.html">int_vector_load_wrapper</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00078.html">int_vector_serialize_min_overhead</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00111.html">random_access_const_iterator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00087.html">lcp_bitcompressed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class which stores the lcp array uncompressed.  <a href="a00087.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html">buffered_char_queue</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html">lcp_dac</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the compressed version of lcp information of an suffix array.  <a href="a00088.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html">lcp_kurtz</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the compressed version of lcp information of an suffix array proposed by Stefan Kurtz in the paper "Reducing the Space Requirement of Suffix Trees".  <a href="a00090.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html">_lcp_support_sada</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the compressed version of lcp information of an suffix array of class Csa proposed by Sadakane in the paper "Succinct Representation of lcp Information and Improvements in the Compressed Suffix Arrays".  <a href="a00006.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html">lcp_support_sada</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class which provides <a class="el" href="a00006.html" title="A class for the compressed version of lcp information of an suffix array of class Csa proposed by Sad...">_lcp_support_sada</a> the context of a CSA.  <a href="a00093.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html">_lcp_support_tree</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00094.html">lcp_support_tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class which provides <a class="el" href="a00007.html">_lcp_support_tree</a> the context of a CST.  <a href="a00094.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html">_lcp_support_tree2</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html">lcp_support_tree2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class which provides <a class="el" href="a00008.html">_lcp_support_tree2</a> the context of a CST.  <a href="a00095.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html">lcp_vlc</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00099.html">lcp_wt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the compressed version of lcp information of an suffix array.  <a href="a00099.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00100.html">louds_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the node representation of <a class="el" href="a00101.html" title="A tree class based on the level order unary degree sequence (LOUDS) representation.">louds_tree</a>.  <a href="a00100.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html">louds_tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tree class based on the level order unary degree sequence (LOUDS) representation.  <a href="a00101.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00104.html">nearest_neighbour_dictionary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nearest neighbour dictionary for sparse uniform sets (described in Geary et al., A Simple Optimal Representation for Balanced Parentheses, CPM 2004).  <a href="a00104.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00105.html">nn_dict_dynamic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for a dynamic bit vector which also supports the prev and next operations.  <a href="a00105.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html">rank_support</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class of classes supporting rank_queries for a <a class="el" href="a00285.html#a93df8f263fced9ae9a8b0f9f37e444eb" title="bit_vector is a specialization of the int_vector.">sdsl::bit_vector</a> in constant time.  <a href="a00115.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html">rank_support_jmc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class supporting rank queries in constant time. The implementation is a lightweight version of the data structure proposed by Jacobson (1989), Munro (1996), and Clark (1996).  <a href="a00117.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html">rank_support_v_trait</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00121.html">rank_support_v_trait&lt; 0, 1 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html">rank_support_v_trait&lt; 1, 1 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00124.html">rank_support_v_trait&lt; 10, 2 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html">rank_support_v_trait&lt; 01, 2 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00118.html">rank_support_v</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class supporting rank queries in constant time. The implementation is a version of the data structure proposed by Vigna (WEA 2008).  <a href="a00118.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html">rank_support_v5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class supporting rank queries in constant time. The implementation is a space saving version of the data structure proposed by Vigna (WEA 2008).  <a href="a00119.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00113.html">range_maximum_support_sada</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00126.html">rmq_succinct_sada</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to support range minimum or range maximum queries on a random access container.  <a href="a00126.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html">range_maximum_sct</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html">rmq_succinct_sct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to support range minimum or range maximum queries on a random access container.  <a href="a00127.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00114.html">range_maximum_support_sparse_table</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html">rmq_support_sparse_table</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to support range minimum or range maximum queries on a random access container.  <a href="a00128.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html">binomial_coefficients_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait class for the binomial coefficient class to handle different type of intergers.  <a href="a00012.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html">binomial_coefficients_trait&lt; 7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="a00012.html" title="Trait class for the binomial coefficient class to handle different type of intergers.">binomial_coefficients_trait</a> for 128-bit integers.  <a href="a00013.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html">binomial_coefficients_trait&lt; 8 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="a00012.html" title="Trait class for the binomial coefficient class to handle different type of intergers.">binomial_coefficients_trait</a> for 256-bit integers.  <a href="a00014.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html">binomial_coefficients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the binomial coefficients up to n.  <a href="a00011.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html">rrr_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to encode and decode binomial coefficients on the fly.  <a href="a00129.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00136.html">rrr_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bit vector which compresses the input with the method from Raman, Raman, and Rao.  <a href="a00136.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00132.html">rrr_rank_support_trait</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html">rrr_rank_support_trait&lt; 0 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html">rrr_rank_support</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00115.html" title="The base class of classes supporting rank_queries for a sdsl::bit_vector in constant time...">rank_support</a> for the <a class="el" href="a00136.html" title="A bit vector which compresses the input with the method from Raman, Raman, and Rao.">rrr_vector</a> class  <a href="a00130.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html">rrr_select_support</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select support for the <a class="el" href="a00136.html" title="A bit vector which compresses the input with the method from Raman, Raman, and Rao.">rrr_vector</a> class.  <a href="a00134.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html">binomial</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html">rrr_vector&lt; 15, wt_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of the <a class="el" href="a00136.html" title="A bit vector which compresses the input with the method from Raman, Raman, and Rao.">rrr_vector</a> class for a block_size of 15.  <a href="a00137.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00131.html">rrr_rank_support&lt; b, 15, wt_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00115.html" title="The base class of classes supporting rank_queries for a sdsl::bit_vector in constant time...">rank_support</a> for the specialized <a class="el" href="a00136.html" title="A bit vector which compresses the input with the method from Raman, Raman, and Rao.">rrr_vector</a> class of block size 15.  <a href="a00131.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00135.html">rrr_select_support&lt; b, 15, wt_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select support for the specialized <a class="el" href="a00136.html" title="A bit vector which compresses the input with the method from Raman, Raman, and Rao.">rrr_vector</a> class of block size 15.  <a href="a00135.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00141.html">sd_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bit vector which compresses very sparse populated bit vectors by.  <a href="a00141.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00139.html">sd_rank_support</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rank data structure for <a class="el" href="a00141.html" title="A bit vector which compresses very sparse populated bit vectors by.">sd_vector</a>.  <a href="a00139.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00140.html">sd_select_support</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select data structure for <a class="el" href="a00141.html" title="A bit vector which compresses very sparse populated bit vectors by.">sd_vector</a>.  <a href="a00140.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00033.html">csa_tag</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html">cst_tag</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html">lcp_plain_tag</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html">lcp_permuted_tag</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00097.html">lcp_tree_compressed_tag</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html">lcp_tree_and_lf_compressed_tag</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00142.html">select_support</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class of classes supporting select queries for a <a class="el" href="a00285.html#a93df8f263fced9ae9a8b0f9f37e444eb" title="bit_vector is a specialization of the int_vector.">sdsl::bit_vector</a> in constant time.  <a href="a00142.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00143.html">select_support_bs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class supporting select quries by using a <a class="el" href="a00115.html" title="The base class of classes supporting rank_queries for a sdsl::bit_vector in constant time...">rank_support</a> and binary search.  <a href="a00143.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html">select_support_dummy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dummy class for select.  <a href="a00144.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00147.html">select_support_mcl_trait</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html">select_support_mcl_trait&lt; 0, 1 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00150.html">select_support_mcl_trait&lt; 1, 1 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html">select_support_mcl_trait&lt; 10, 2 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00149.html">select_support_mcl_trait&lt; 01, 2 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00146.html">select_support_mcl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class supporting constant time select queries (proposed by Munro/Clark, 1996) enhanced by broadword computing tricks.  <a href="a00146.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html">sorted_int_stack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stack class which can contain integers from <img class="formulaInl" alt="$0$" src="form_228.png"/> to <img class="formulaInl" alt="$n-1$" src="form_229.png"/> in sorted order.  <a href="a00152.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00153.html">sorted_multi_stack_support</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stack class which contains ...  <a href="a00153.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00154.html">sorted_stack_support</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stack class which contains indices of elements from an random access container and the elements are in sorted order on the stack.  <a href="a00154.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00157.html">structure_tree_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for a node of the structure tree.  <a href="a00157.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html">structure_tree</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html">psi_of_csa_psi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for the <img class="formulaInl" alt="$\Psi$" src="form_6.png"/> and LF function for (compressed) suffix arrays that are based on the compressed <img class="formulaInl" alt="$\Psi$" src="form_6.png"/> function.  <a href="a00108.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html">psi_of_sa_and_isa</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for the <img class="formulaInl" alt="$\Psi$" src="form_6.png"/> function for (compressed) suffix arrays which provide also the inverse suffix array values (like <a class="el" href="a00034.html" title="A class for the uncmpressed suffix array (SA).">sdsl::csa_uncompressed</a>).  <a href="a00110.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00024.html">bwt_of_csa_psi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for the bwt of a compressed suffix array that is based on the <img class="formulaInl" alt="$\psi$" src="form_230.png"/> function.  <a href="a00024.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00158.html">temp_write_read_buffer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00159.html">template_class</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short description for what <a class="el" href="a00159.html" title="Short description for what template_class is used here.">template_class</a> is used here.  <a href="a00159.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html">stop_watch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to meassure the time consumption of program pieces.  <a href="a00155.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00027.html">clock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to get time information.  <a href="a00027.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00064.html">file</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to handle files.  <a href="a00064.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html">uint256_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html">vlc_vector_trait</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00175.html">vlc_vector_trait&lt; 32 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00173.html">vlc_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic immutable space-saving vector class for unsigned positive integers.  <a href="a00173.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00172.html">unsigned_char_map</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00182.html">wt_trait</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00183.html">wt_trait&lt; character * &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html">wt_trait&lt; unsigned char * &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00184.html">wt_trait&lt; int_vector_file_buffer&lt; 8, size_type_class &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html">wt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wavelet tree class.  <a href="a00176.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html">_node</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html">wt_huff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Wavelet Tree class for byte sequences.  <a href="a00177.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00178.html">wt_int</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wavelet tree class for sequences of big alphabet size (like integer alphabet)  <a href="a00178.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html">wt_rlg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Wavelet Tree class for byte sequences.  <a href="a00179.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html">wt_rlg8</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Wavelet Tree class for byte sequences.  <a href="a00180.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html">wt_rlmn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Wavelet Tree class for byte sequences.  <a href="a00181.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8c93cd5343cbafc4d1b44861231d6a07"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c93cd5343cbafc4d1b44861231d6a07"></a>
typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>std_size_type_for_int_vector</b></td></tr>
<tr class="memitem:a93df8f263fced9ae9a8b0f9f37e444eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93df8f263fced9ae9a8b0f9f37e444eb"></a>
typedef <a class="el" href="a00068.html">int_vector</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00285.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a></td></tr>
<tr class="memdesc:a93df8f263fced9ae9a8b0f9f37e444eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">bit_vector is a specialization of the <a class="el" href="a00068.html" title="A generic vector class for integers of width .">int_vector</a>. <br/></td></tr>
<tr class="memitem:ae8672206e98803e0530ed9541ca5d8ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8672206e98803e0530ed9541ca5d8ea"></a>
typedef std::list&lt; <a class="el" href="a00068.html">int_vector</a><br class="typebreak"/>
&lt;&gt;::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tLI</b></td></tr>
<tr class="memitem:ab74bbd5b19812bed437ae3ede9eab50c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab74bbd5b19812bed437ae3ede9eab50c"></a>
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="a00068.html">int_vector</a>&lt;&gt;::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tVI</b></td></tr>
<tr class="memitem:a254e0582cdc78b259b2294d6687c28d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a254e0582cdc78b259b2294d6687c28d8"></a>
typedef std::map&lt; std::string, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tMSS</b></td></tr>
<tr class="memitem:ac4851d5c2b608f04bff98d170b60ffd0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4851d5c2b608f04bff98d170b60ffd0"></a>
typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tVS</b></td></tr>
<tr class="memitem:a2537aa8063ec7bb70da91ac471761bb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2537aa8063ec7bb70da91ac471761bb3"></a>
typedef unsigned int uint128_t&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b> ((mode(TI)))</td></tr>
<tr class="memitem:aa2567c0ab442126aeeae17f56e381fcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2567c0ab442126aeeae17f56e381fcd"></a>
typedef <a class="el" href="a00177.html">wt_huff</a>&lt; <a class="el" href="a00136.html">rrr_vector</a><br class="typebreak"/>
&lt;&gt;, <a class="el" href="a00136.html">rrr_vector</a>&lt;&gt;::rank_1_type, <br class="typebreak"/>
<a class="el" href="a00136.html">rrr_vector</a>&lt;&gt;::select_1_type, <br class="typebreak"/>
<a class="el" href="a00136.html">rrr_vector</a>&lt;&gt;::select_0_type, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>wt_huff_rrr</b></td></tr>
<tr class="memitem:a52dd5e6787e1465b6c4936428c63280c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52dd5e6787e1465b6c4936428c63280c"></a>
typedef <a class="el" href="a00177.html">wt_huff</a>&lt; <a class="el" href="a00285.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a>, <br class="typebreak"/>
<a class="el" href="a00119.html">rank_support_v5</a><br class="typebreak"/>
&lt;&gt;, <a class="el" href="a00143.html">select_support_bs</a><br class="typebreak"/>
&lt;&gt;, <a class="el" href="a00143.html">select_support_bs</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>wt_without_select</b></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:acfcb92cdb3212158a254eaa4e1183666"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>format_type</b> { <b>JSON_FORMAT</b>, 
<b>R_FORMAT</b>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a396b6b833af2ec71736f28b65b23e605"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00285.html#a396b6b833af2ec71736f28b65b23e605">construct_bwt</a> (tMSS &amp;file_map, const std::string &amp;dir, const std::string &amp;id)</td></tr>
<tr class="memitem:ae684def0fb2836cb1ded6b0421018173"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae684def0fb2836cb1ded6b0421018173"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>construct_bwt2</b> (tMSS &amp;file_map, const std::string &amp;dir, const std::string &amp;id)</td></tr>
<tr class="memitem:a61e36f6ef479659907d35f9104339fec"><td class="memTemplParams" colspan="2"><a class="anchor" id="a61e36f6ef479659907d35f9104339fec"></a>
template&lt;class Int &gt; </td></tr>
<tr class="memitem:a61e36f6ef479659907d35f9104339fec"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a00018.html">bp_interval_p</a>&lt; Int &gt; &amp;interval)</td></tr>
<tr class="memitem:a4a5f92e46f9ed01d3bb74787146bbfaf"><td class="memTemplParams" colspan="2">template&lt;class Cst &gt; </td></tr>
<tr class="memitem:a4a5f92e46f9ed01d3bb74787146bbfaf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a4a5f92e46f9ed01d3bb74787146bbfaf">construct_cst</a> (std::string file_name, Cst &amp;cst)</td></tr>
<tr class="memdesc:a4a5f92e46f9ed01d3bb74787146bbfaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a compressed suffix tree (cst) by a semi-external algorithm.  <a href="#a4a5f92e46f9ed01d3bb74787146bbfaf"></a><br/></td></tr>
<tr class="memitem:a4f261e33bcd712b64dc413089d6ddfa8"><td class="memTemplParams" colspan="2">template&lt;class Cst &gt; </td></tr>
<tr class="memitem:a4f261e33bcd712b64dc413089d6ddfa8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a4f261e33bcd712b64dc413089d6ddfa8">construct_cst</a> (std::string file_name, Cst &amp;cst, tMSS &amp;file_map, bool delete_files=true, std::string dir=&quot;./&quot;, bool build_only_bps=false, std::string id=&quot;&quot;, std::string lcp_method=&quot;any&quot;)</td></tr>
<tr class="memdesc:a4f261e33bcd712b64dc413089d6ddfa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a compressed suffix tree (cst) semi-external.  <a href="#a4f261e33bcd712b64dc413089d6ddfa8"></a><br/></td></tr>
<tr class="memitem:a4b9f5e5d8096fa99c3e7bf744399c06d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b9f5e5d8096fa99c3e7bf744399c06d"></a>
template&lt;class Int &gt; </td></tr>
<tr class="memitem:a4b9f5e5d8096fa99c3e7bf744399c06d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a00089.html">lcp_interval</a>&lt; Int &gt; &amp;interval)</td></tr>
<tr class="memitem:a56a1f9c3486668906a4ea66795db468b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a56a1f9c3486668906a4ea66795db468b"></a>
template&lt;class Int &gt; </td></tr>
<tr class="memitem:a56a1f9c3486668906a4ea66795db468b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a00017.html">bp_interval</a>&lt; Int &gt; &amp;interval)</td></tr>
<tr class="memitem:a20393b6b6cf8245aa525b643a36176cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20393b6b6cf8245aa525b643a36176cf"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>decode64bit</b> (uint64_t w)</td></tr>
<tr class="memitem:ad8ca33a4202bbcefcb136ed695debdd8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad8ca33a4202bbcefcb136ed695debdd8"></a>
template&lt;class int_vector &gt; </td></tr>
<tr class="memitem:ad8ca33a4202bbcefcb136ed695debdd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00071.html">int_vector_iterator</a>&lt; <a class="el" href="a00068.html">int_vector</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (typename <a class="el" href="a00071.html">int_vector_iterator</a>&lt; <a class="el" href="a00068.html">int_vector</a> &gt;::difference_type n, const <a class="el" href="a00071.html">int_vector_iterator</a>&lt; <a class="el" href="a00068.html">int_vector</a> &gt; &amp;it)</td></tr>
<tr class="memitem:ad2be861d11795ed9a03afd41020053dd"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad2be861d11795ed9a03afd41020053dd"></a>
template&lt;class int_vector &gt; </td></tr>
<tr class="memitem:ad2be861d11795ed9a03afd41020053dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00069.html">int_vector_const_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="a00068.html">int_vector</a> &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="a00069.html">int_vector_const_iterator</a>&lt; <a class="el" href="a00068.html">int_vector</a> &gt; &amp;x, const <a class="el" href="a00069.html">int_vector_const_iterator</a>&lt; <a class="el" href="a00068.html">int_vector</a> &gt; &amp;y)</td></tr>
<tr class="memitem:a35f48db0edcfbc1dacca803d5e6a24e9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a35f48db0edcfbc1dacca803d5e6a24e9"></a>
template&lt;class int_vector &gt; </td></tr>
<tr class="memitem:a35f48db0edcfbc1dacca803d5e6a24e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00069.html">int_vector_const_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="a00068.html">int_vector</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (typename <a class="el" href="a00069.html">int_vector_const_iterator</a>&lt; <a class="el" href="a00068.html">int_vector</a> &gt;::difference_type n, const <a class="el" href="a00069.html">int_vector_const_iterator</a>&lt; <a class="el" href="a00068.html">int_vector</a> &gt; &amp;it)</td></tr>
<tr class="memitem:a8fa9e88cf7859bd834ac9b12dc3931b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fa9e88cf7859bd834ac9b12dc3931b5"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a00068.html">int_vector</a>&lt; 1 &gt; &amp;v)</td></tr>
<tr class="memitem:aca89230548f6ad69d04aa1f8e85143f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca89230548f6ad69d04aa1f8e85143f2"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a00068.html">int_vector</a>&lt; 0 &gt; &amp;v)</td></tr>
<tr class="memitem:a5c7628fc70bba30e310e16c971b72a72"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5c7628fc70bba30e310e16c971b72a72"></a>
template&lt;class size_type_class &gt; </td></tr>
<tr class="memitem:a5c7628fc70bba30e310e16c971b72a72"><td class="memTemplItemLeft" align="right" valign="top">size_type_class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_sdsl_serialize_size_and_int_width</b> (std::ostream &amp;out, uint8_t fixed_int_width, uint8_t int_width, size_type_class size)</td></tr>
<tr class="memitem:aa1800d2ffff6fb79021c88b7c9e6caac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1800d2ffff6fb79021c88b7c9e6caac"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>construct_isa</b> (tMSS &amp;file_map, const std::string &amp;dir, const std::string &amp;id)</td></tr>
<tr class="memitem:ace3686eb1137a70b264621e0c3ae238a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ace3686eb1137a70b264621e0c3ae238a"></a>
template&lt;class RandomAccessContainer &gt; </td></tr>
<tr class="memitem:ace3686eb1137a70b264621e0c3ae238a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00111.html">random_access_const_iterator</a><br class="typebreak"/>
&lt; RandomAccessContainer &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="a00111.html">random_access_const_iterator</a>&lt; RandomAccessContainer &gt; &amp;x, const <a class="el" href="a00111.html">random_access_const_iterator</a>&lt; RandomAccessContainer &gt; &amp;y)</td></tr>
<tr class="memitem:a3394b5dca20a68575df0261011ed052e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3394b5dca20a68575df0261011ed052e"></a>
template&lt;class RandomAccessContainer &gt; </td></tr>
<tr class="memitem:a3394b5dca20a68575df0261011ed052e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00111.html">random_access_const_iterator</a><br class="typebreak"/>
&lt; RandomAccessContainer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (typename <a class="el" href="a00111.html">random_access_const_iterator</a>&lt; RandomAccessContainer &gt;::difference_type n, const <a class="el" href="a00111.html">random_access_const_iterator</a>&lt; RandomAccessContainer &gt; &amp;it)</td></tr>
<tr class="memitem:a0b1236eeb07b4584bc222faaa2685ff5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0b1236eeb07b4584bc222faaa2685ff5"></a>
template&lt;class Lcp , class Cst , uint8_t int_width, class size_type_class , uint8_t int_width1, class size_type_class1 &gt; </td></tr>
<tr class="memitem:a0b1236eeb07b4584bc222faaa2685ff5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>construct_lcp</b> (Lcp &amp;lcp, const Cst &amp;cst, <a class="el" href="a00070.html">int_vector_file_buffer</a>&lt; int_width, size_type_class &gt; &amp;lcp_buf, <a class="el" href="a00070.html">int_vector_file_buffer</a>&lt; int_width1, size_type_class1 &gt; &amp;isa_buf)</td></tr>
<tr class="memitem:a3c9a73f6130a68eb9f441f42483c965f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c9a73f6130a68eb9f441f42483c965f"></a>
template&lt;class Lcp , class Cst , uint8_t int_width, class size_type_class , uint8_t int_width1, class size_type_class1 &gt; </td></tr>
<tr class="memitem:a3c9a73f6130a68eb9f441f42483c965f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>construct_lcp</b> (Lcp &amp;lcp, const Cst &amp;cst, <a class="el" href="a00070.html">int_vector_file_buffer</a>&lt; int_width, size_type_class &gt; &amp;lcp_buf, <a class="el" href="a00070.html">int_vector_file_buffer</a>&lt; int_width1, size_type_class1 &gt; &amp;isa_buf, <a class="el" href="a00092.html">lcp_plain_tag</a>)</td></tr>
<tr class="memitem:adb415ab46da7142cd0dabedca9eacbf2"><td class="memTemplParams" colspan="2"><a class="anchor" id="adb415ab46da7142cd0dabedca9eacbf2"></a>
template&lt;class Lcp , class Cst , uint8_t int_width, class size_type_class , uint8_t int_width1, class size_type_class1 &gt; </td></tr>
<tr class="memitem:adb415ab46da7142cd0dabedca9eacbf2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>construct_lcp</b> (Lcp &amp;lcp, const Cst &amp;cst, <a class="el" href="a00070.html">int_vector_file_buffer</a>&lt; int_width, size_type_class &gt; &amp;lcp_buf, <a class="el" href="a00070.html">int_vector_file_buffer</a>&lt; int_width1, size_type_class1 &gt; &amp;isa_buf, <a class="el" href="a00091.html">lcp_permuted_tag</a>)</td></tr>
<tr class="memitem:a4effbaf5cd81a73fff25faa6ee7d03dd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4effbaf5cd81a73fff25faa6ee7d03dd"></a>
template&lt;class Lcp , class Cst , uint8_t int_width, class size_type_class , uint8_t int_width1, class size_type_class1 &gt; </td></tr>
<tr class="memitem:a4effbaf5cd81a73fff25faa6ee7d03dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>construct_lcp</b> (Lcp &amp;lcp, const Cst &amp;cst, <a class="el" href="a00070.html">int_vector_file_buffer</a>&lt; int_width, size_type_class &gt; &amp;lcp_buf, <a class="el" href="a00070.html">int_vector_file_buffer</a>&lt; int_width1, size_type_class1 &gt; &amp;isa_buf, <a class="el" href="a00097.html">lcp_tree_compressed_tag</a>)</td></tr>
<tr class="memitem:a044349f842ecf203bb99a4dc0b00d2c3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a044349f842ecf203bb99a4dc0b00d2c3"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:a044349f842ecf203bb99a4dc0b00d2c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>construct_lcp</b> (Lcp &amp;lcp, const Cst &amp;cst, tMSS &amp;file_map, const std::string dir, const std::string id)</td></tr>
<tr class="memitem:a8501173ac4fa11efe0dcca90d5ae112c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8501173ac4fa11efe0dcca90d5ae112c"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:a8501173ac4fa11efe0dcca90d5ae112c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>construct_lcp</b> (Lcp &amp;lcp, const Cst &amp;cst, tMSS &amp;file_map, const std::string dir, const std::string id, <a class="el" href="a00092.html">lcp_plain_tag</a>)</td></tr>
<tr class="memitem:abbbbc0532488a6e5d46a875334055d29"><td class="memTemplParams" colspan="2"><a class="anchor" id="abbbbc0532488a6e5d46a875334055d29"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:abbbbc0532488a6e5d46a875334055d29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>construct_lcp</b> (Lcp &amp;lcp, const Cst &amp;cst, tMSS &amp;file_map, const std::string dir, const std::string id, <a class="el" href="a00091.html">lcp_permuted_tag</a>)</td></tr>
<tr class="memitem:af1babd0aa553d223b458a6ec969ae929"><td class="memTemplParams" colspan="2"><a class="anchor" id="af1babd0aa553d223b458a6ec969ae929"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:af1babd0aa553d223b458a6ec969ae929"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>construct_lcp</b> (Lcp &amp;lcp, const Cst &amp;cst, tMSS &amp;file_map, const std::string dir, const std::string id, <a class="el" href="a00097.html">lcp_tree_compressed_tag</a>)</td></tr>
<tr class="memitem:afe3094436b7f4fc84c0872b8e64dd0b0"><td class="memTemplParams" colspan="2"><a class="anchor" id="afe3094436b7f4fc84c0872b8e64dd0b0"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:afe3094436b7f4fc84c0872b8e64dd0b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>construct_lcp</b> (Lcp &amp;lcp, const Cst &amp;cst, tMSS &amp;file_map, const std::string dir, const std::string id, <a class="el" href="a00096.html">lcp_tree_and_lf_compressed_tag</a>)</td></tr>
<tr class="memitem:a765c28e35fce75bd98022362ce91779f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a765c28e35fce75bd98022362ce91779f"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:a765c28e35fce75bd98022362ce91779f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_lcp</b> (Lcp &amp;lcp, const Lcp &amp;lcp_c, const Cst &amp;cst)</td></tr>
<tr class="memitem:acca11ad62b0da3804c019e7347d70db3"><td class="memTemplParams" colspan="2"><a class="anchor" id="acca11ad62b0da3804c019e7347d70db3"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:acca11ad62b0da3804c019e7347d70db3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_lcp</b> (Lcp &amp;lcp, const Lcp &amp;lcp_c, const Cst &amp;cst, <a class="el" href="a00092.html">lcp_plain_tag</a>)</td></tr>
<tr class="memitem:a86e49281e7887626fb3675a2719c1081"><td class="memTemplParams" colspan="2"><a class="anchor" id="a86e49281e7887626fb3675a2719c1081"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:a86e49281e7887626fb3675a2719c1081"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_lcp</b> (Lcp &amp;lcp, const Lcp &amp;lcp_c, const Cst &amp;cst, <a class="el" href="a00091.html">lcp_permuted_tag</a>)</td></tr>
<tr class="memitem:a5863104543279c9cb91b6a0bff6a2391"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5863104543279c9cb91b6a0bff6a2391"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:a5863104543279c9cb91b6a0bff6a2391"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_lcp</b> (Lcp &amp;lcp, const Lcp &amp;lcp_c, const Cst &amp;cst, <a class="el" href="a00097.html">lcp_tree_compressed_tag</a>)</td></tr>
<tr class="memitem:aa47b6073dbad0235d87fc414b51168ee"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa47b6073dbad0235d87fc414b51168ee"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:aa47b6073dbad0235d87fc414b51168ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_lcp</b> (Lcp &amp;lcp, const Lcp &amp;lcp_c, const Cst &amp;cst, <a class="el" href="a00096.html">lcp_tree_and_lf_compressed_tag</a>)</td></tr>
<tr class="memitem:a38fecc971b95124b67f4452269176ad0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a38fecc971b95124b67f4452269176ad0"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:a38fecc971b95124b67f4452269176ad0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap_lcp</b> (Lcp &amp;lcp1, Lcp &amp;lcp2, const Cst &amp;cst1, const Cst &amp;cst2)</td></tr>
<tr class="memitem:a2cf736efba2a36d2730db78cda72d3c1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2cf736efba2a36d2730db78cda72d3c1"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:a2cf736efba2a36d2730db78cda72d3c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap_lcp</b> (Lcp &amp;lcp1, Lcp &amp;lcp2, const Cst &amp;cst1, const Cst &amp;cst2, <a class="el" href="a00092.html">lcp_plain_tag</a>)</td></tr>
<tr class="memitem:a9e4858eae4c43635159e39e34531fcc3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9e4858eae4c43635159e39e34531fcc3"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:a9e4858eae4c43635159e39e34531fcc3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap_lcp</b> (Lcp &amp;lcp1, Lcp &amp;lcp2, const Cst &amp;cst1, const Cst &amp;cst2, <a class="el" href="a00091.html">lcp_permuted_tag</a>)</td></tr>
<tr class="memitem:aea28a36b040e48028309b523b2bea164"><td class="memTemplParams" colspan="2"><a class="anchor" id="aea28a36b040e48028309b523b2bea164"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:aea28a36b040e48028309b523b2bea164"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap_lcp</b> (Lcp &amp;lcp1, Lcp &amp;lcp2, const Cst &amp;cst1, const Cst &amp;cst2, <a class="el" href="a00097.html">lcp_tree_compressed_tag</a>)</td></tr>
<tr class="memitem:aefffc135b06eb584c87b06f5588638a4"><td class="memTemplParams" colspan="2"><a class="anchor" id="aefffc135b06eb584c87b06f5588638a4"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:aefffc135b06eb584c87b06f5588638a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap_lcp</b> (Lcp &amp;lcp1, Lcp &amp;lcp2, const Cst &amp;cst1, const Cst &amp;cst2, <a class="el" href="a00096.html">lcp_tree_and_lf_compressed_tag</a>)</td></tr>
<tr class="memitem:a9fec0293a3751170067f452a3d352867"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9fec0293a3751170067f452a3d352867"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:a9fec0293a3751170067f452a3d352867"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>load_lcp</b> (Lcp &amp;lcp, std::istream &amp;in, const Cst &amp;cst)</td></tr>
<tr class="memitem:aecf51369c3a4751abde9a666ac228daa"><td class="memTemplParams" colspan="2"><a class="anchor" id="aecf51369c3a4751abde9a666ac228daa"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:aecf51369c3a4751abde9a666ac228daa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>load_lcp</b> (Lcp &amp;lcp, std::istream &amp;in, const Cst &amp;cst, <a class="el" href="a00092.html">lcp_plain_tag</a>)</td></tr>
<tr class="memitem:a11cad1cd3977dda267566fc251aed2b9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a11cad1cd3977dda267566fc251aed2b9"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:a11cad1cd3977dda267566fc251aed2b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>load_lcp</b> (Lcp &amp;lcp, std::istream &amp;in, const Cst &amp;cst, <a class="el" href="a00091.html">lcp_permuted_tag</a>)</td></tr>
<tr class="memitem:a31a290442d3955de663f977753d1f0d3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a31a290442d3955de663f977753d1f0d3"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:a31a290442d3955de663f977753d1f0d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>load_lcp</b> (Lcp &amp;lcp, std::istream &amp;in, const Cst &amp;cst, <a class="el" href="a00097.html">lcp_tree_compressed_tag</a>)</td></tr>
<tr class="memitem:aaded2ca5c79dfe06a8522116809eb31e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaded2ca5c79dfe06a8522116809eb31e"></a>
template&lt;class Lcp , class Cst &gt; </td></tr>
<tr class="memitem:aaded2ca5c79dfe06a8522116809eb31e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>load_lcp</b> (Lcp &amp;lcp, std::istream &amp;in, const Cst &amp;cst, <a class="el" href="a00096.html">lcp_tree_and_lf_compressed_tag</a>)</td></tr>
<tr class="memitem:a3daccd09d4dbb93edd609e31377228de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00285.html#a3daccd09d4dbb93edd609e31377228de">construct_lcp_kasai</a> (tMSS &amp;file_map, const std::string &amp;dir, const std::string &amp;id)</td></tr>
<tr class="memdesc:a3daccd09d4dbb93edd609e31377228de"><td class="mdescLeft">&#160;</td><td class="mdescRight">5n byte variant of the algorithm of Kasai et al. (CPM 2001, "Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its Applications")  <a href="#a3daccd09d4dbb93edd609e31377228de"></a><br/></td></tr>
<tr class="memitem:ab8f90c42972b80152de87cbb323d2f35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8f90c42972b80152de87cbb323d2f35"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>construct_lcp_semi_extern_PHI</b> (tMSS &amp;file_map, const std::string &amp;dir, const std::string &amp;id)</td></tr>
<tr class="memitem:a34d793ed42593dc3d878662668c57b14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00285.html#a34d793ed42593dc3d878662668c57b14">construct_lcp_PHI</a> (tMSS &amp;file_map, const std::string &amp;dir, const std::string &amp;id, bool semi_external=false)</td></tr>
<tr class="memdesc:a34d793ed42593dc3d878662668c57b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">5n byte variant of the algorithm of Kaerkkaeinen et al. (CPM 2009, "Permuted Longest Common Prefix Array")  <a href="#a34d793ed42593dc3d878662668c57b14"></a><br/></td></tr>
<tr class="memitem:af41b231071f923d7d34c27bfc73d8bc9"><td class="memTemplParams" colspan="2"><a class="anchor" id="af41b231071f923d7d34c27bfc73d8bc9"></a>
template&lt;class size_type_class &gt; </td></tr>
<tr class="memitem:af41b231071f923d7d34c27bfc73d8bc9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>push_front_m_index</b> (size_type_class i, uint8_t c, tLI(&amp;m_list)[256], uint8_t(&amp;m_chars)[256], size_type_class &amp;m_char_count)</td></tr>
<tr class="memitem:a13c1b0058508b0a172209891968381ac"><td class="memTemplParams" colspan="2"><a class="anchor" id="a13c1b0058508b0a172209891968381ac"></a>
template&lt;class size_type_class &gt; </td></tr>
<tr class="memitem:a13c1b0058508b0a172209891968381ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>push_back_m_index</b> (size_type_class i, uint8_t c, tLI(&amp;m_list)[256], uint8_t(&amp;m_chars)[256], size_type_class &amp;m_char_count)</td></tr>
<tr class="memitem:ac13a293e5616ac0b372be6e37a718d11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac13a293e5616ac0b372be6e37a718d11"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>construct_lcp_simple_5n</b> (tMSS &amp;file_map, const std::string &amp;dir, const std::string &amp;id)</td></tr>
<tr class="memitem:a25a88a3d39318ac0acb23f246ba4da5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25a88a3d39318ac0acb23f246ba4da5b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>construct_lcp_simple2_9n</b> (tMSS &amp;file_map, const std::string &amp;dir, const std::string &amp;id)</td></tr>
<tr class="memitem:aab2eca3099c5d212934bcfddd54261a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00285.html#aab2eca3099c5d212934bcfddd54261a4">construct_lcp_go</a> (tMSS &amp;file_map, const std::string &amp;dir, const std::string &amp;id)</td></tr>
<tr class="memdesc:aab2eca3099c5d212934bcfddd54261a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our new 2 phases lcp algorithm using usually 2n bytes.  <a href="#aab2eca3099c5d212934bcfddd54261a4"></a><br/></td></tr>
<tr class="memitem:a0c672fbb78beb8b55ec3bfd763f7365a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00285.html#a0c672fbb78beb8b55ec3bfd763f7365a">construct_lcp_goPHI</a> (tMSS &amp;file_map, const std::string &amp;dir, const std::string &amp;id)</td></tr>
<tr class="memdesc:a0c672fbb78beb8b55ec3bfd763f7365a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our new 2 phases lcp algorithm using usually 2n bytes.  <a href="#a0c672fbb78beb8b55ec3bfd763f7365a"></a><br/></td></tr>
<tr class="memitem:aa99d7a193bf9889994ef8bc1cb3da646"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00285.html#aa99d7a193bf9889994ef8bc1cb3da646">construct_lcp_go2</a> (tMSS &amp;file_map, const std::string &amp;dir, const std::string &amp;id)</td></tr>
<tr class="memdesc:aa99d7a193bf9889994ef8bc1cb3da646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our new 2 phases lcp algorithm using usually 1 n bytes.  <a href="#aa99d7a193bf9889994ef8bc1cb3da646"></a><br/></td></tr>
<tr class="memitem:aca6b6154d2cc20aec31d986684f39b5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca6b6154d2cc20aec31d986684f39b5a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>lcp_info</b> (tMSS &amp;file_map)</td></tr>
<tr class="memitem:a1e7223b0ea6e774d0c549e3fb8a16d59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e7223b0ea6e774d0c549e3fb8a16d59"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a00100.html">louds_node</a> &amp;v)</td></tr>
<tr class="memitem:a2c02c5b1e93fe4ae85af5082ec5c247c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2c02c5b1e93fe4ae85af5082ec5c247c"></a>
template&lt;format_type F&gt; </td></tr>
<tr class="memitem:a2c02c5b1e93fe4ae85af5082ec5c247c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>write_structure_tree</b> (const <a class="el" href="a00157.html">structure_tree_node</a> *v, std::ostream &amp;out)</td></tr>
<tr class="memitem:ac80054ed6a03880ca9d4065ffe3f6c0a"><td class="memTemplParams" colspan="2">template&lt;class tCst &gt; </td></tr>
<tr class="memitem:ac80054ed6a03880ca9d4065ffe3f6c0a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#ac80054ed6a03880ca9d4065ffe3f6c0a">H0</a> (const typename tCst::node_type &amp;v, const tCst &amp;cst)</td></tr>
<tr class="memdesc:ac80054ed6a03880ca9d4065ffe3f6c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the zeroth order entropy of the text that follows a certain substring s.  <a href="#ac80054ed6a03880ca9d4065ffe3f6c0a"></a><br/></td></tr>
<tr class="memitem:ab60aeaabd7287956f8cfccdb34d71f8d"><td class="memTemplParams" colspan="2">template&lt;class tCst &gt; </td></tr>
<tr class="memitem:ab60aeaabd7287956f8cfccdb34d71f8d"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#ab60aeaabd7287956f8cfccdb34d71f8d">Hk</a> (const tCst &amp;cst, typename tCst::size_type k, typename tCst::size_type &amp;context)</td></tr>
<tr class="memdesc:ab60aeaabd7287956f8cfccdb34d71f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the k-th order entropy of a text.  <a href="#ab60aeaabd7287956f8cfccdb34d71f8d"></a><br/></td></tr>
<tr class="memitem:a1651e842a890b41fd33d537a726d81d5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1651e842a890b41fd33d537a726d81d5"></a>
template&lt;class Csa &gt; </td></tr>
<tr class="memitem:a1651e842a890b41fd33d537a726d81d5"><td class="memTemplItemLeft" align="right" valign="top">Csa::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_char_pos</b> (typename Csa::size_type idx, typename Csa::size_type d, const Csa &amp;csa)</td></tr>
<tr class="memitem:a9f5fc126859d8c6f039fc67d6738c7f5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9f5fc126859d8c6f039fc67d6738c7f5"></a>
template&lt;class Cst &gt; </td></tr>
<tr class="memitem:a9f5fc126859d8c6f039fc67d6738c7f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cst_info</b> (const Cst &amp;cst)</td></tr>
<tr class="memitem:a2cf94834fbf70b7144b0db7c9d73a5da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cf94834fbf70b7144b0db7c9d73a5da"></a>
<a class="el" href="a00068.html">int_vector</a>&lt; 64 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00285.html#a2cf94834fbf70b7144b0db7c9d73a5da">get_rnd_positions</a> (uint8_t log_s, uint64_t &amp;mask, uint64_t m=0, uint64_t x=17)</td></tr>
<tr class="memdesc:a2cf94834fbf70b7144b0db7c9d73a5da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create 1^{log_s} random intergers mod m with seed x. <br/></td></tr>
<tr class="memitem:a0539789b0c02c92136f49bdb04529bb4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0539789b0c02c92136f49bdb04529bb4"></a>
template&lt;class Vector &gt; </td></tr>
<tr class="memitem:a0539789b0c02c92136f49bdb04529bb4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_int_vector_random_access</b> (const Vector &amp;v, bit_vector::size_type times=100000000)</td></tr>
<tr class="memitem:aea7a625e151d06acd3c638aed5b78062"><td class="memTemplParams" colspan="2"><a class="anchor" id="aea7a625e151d06acd3c638aed5b78062"></a>
template&lt;class Vector &gt; </td></tr>
<tr class="memitem:aea7a625e151d06acd3c638aed5b78062"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_int_vector_random_write</b> (Vector &amp;v, bit_vector::size_type times=100000000)</td></tr>
<tr class="memitem:a7d5bd69ac048daac059bc6861cadaab8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7d5bd69ac048daac059bc6861cadaab8"></a>
template&lt;class Vector &gt; </td></tr>
<tr class="memitem:a7d5bd69ac048daac059bc6861cadaab8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_int_vector_sequential_write</b> (Vector &amp;v, bit_vector::size_type times=100000000)</td></tr>
<tr class="memitem:a4fd2534080e7f265af5bf11e7f722cab"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4fd2534080e7f265af5bf11e7f722cab"></a>
template&lt;class Rank &gt; </td></tr>
<tr class="memitem:a4fd2534080e7f265af5bf11e7f722cab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a4fd2534080e7f265af5bf11e7f722cab">test_rank_random_access</a> (const Rank &amp;rank, bit_vector::size_type times=20000000)</td></tr>
<tr class="memdesc:a4fd2534080e7f265af5bf11e7f722cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test random queries on rank data structure. <br/></td></tr>
<tr class="memitem:a9cd400ff0a5d7223b2269bcc717225ef"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9cd400ff0a5d7223b2269bcc717225ef"></a>
template&lt;class Rank &gt; </td></tr>
<tr class="memitem:a9cd400ff0a5d7223b2269bcc717225ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a9cd400ff0a5d7223b2269bcc717225ef">test_rank_construction</a> (bit_vector::size_type size=838860800)</td></tr>
<tr class="memdesc:a9cd400ff0a5d7223b2269bcc717225ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test creation time for a rank data structure. <br/></td></tr>
<tr class="memitem:af9a58013e4c604765d84f7d779f035a8"><td class="memTemplParams" colspan="2"><a class="anchor" id="af9a58013e4c604765d84f7d779f035a8"></a>
template&lt;class Select &gt; </td></tr>
<tr class="memitem:af9a58013e4c604765d84f7d779f035a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#af9a58013e4c604765d84f7d779f035a8">test_select_random_access</a> (const Select &amp;select, bit_vector::size_type times=20000000)</td></tr>
<tr class="memdesc:af9a58013e4c604765d84f7d779f035a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test random queries on select data structure. <br/></td></tr>
<tr class="memitem:a9aa13ae163481f05d88c45c4c1079530"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9aa13ae163481f05d88c45c4c1079530"></a>
template&lt;class Select &gt; </td></tr>
<tr class="memitem:a9aa13ae163481f05d88c45c4c1079530"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a9aa13ae163481f05d88c45c4c1079530">test_select_random_access</a> (const Select &amp;select, bit_vector::size_type args, bit_vector::size_type times)</td></tr>
<tr class="memdesc:a9aa13ae163481f05d88c45c4c1079530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test random queries on select data structure. <br/></td></tr>
<tr class="memitem:ab3f934e983a3a94957c358fbd5412f90"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab3f934e983a3a94957c358fbd5412f90"></a>
template&lt;class Select &gt; </td></tr>
<tr class="memitem:ab3f934e983a3a94957c358fbd5412f90"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#ab3f934e983a3a94957c358fbd5412f90">test_select_construction</a> (bit_vector::size_type size=838860800)</td></tr>
<tr class="memdesc:ab3f934e983a3a94957c358fbd5412f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test creation time for a rank data structure. <br/></td></tr>
<tr class="memitem:aeb773a465a2756ea63faee446659ac83"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeb773a465a2756ea63faee446659ac83"></a>
template&lt;class Csa &gt; </td></tr>
<tr class="memitem:aeb773a465a2756ea63faee446659ac83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_csa_access</b> (const Csa &amp;csa, typename Csa::size_type times=1000000)</td></tr>
<tr class="memitem:ac742f41d6f74241ebf3e9588039f2c4d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac742f41d6f74241ebf3e9588039f2c4d"></a>
template&lt;class Csa &gt; </td></tr>
<tr class="memitem:ac742f41d6f74241ebf3e9588039f2c4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_icsa_access</b> (const Csa &amp;csa, typename Csa::size_type times=1000000)</td></tr>
<tr class="memitem:a6f5bf63973af619c58480ad643eb5905"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6f5bf63973af619c58480ad643eb5905"></a>
template&lt;class Csa &gt; </td></tr>
<tr class="memitem:a6f5bf63973af619c58480ad643eb5905"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_psi_access</b> (const Csa &amp;csa, typename Csa::size_type times=1000000)</td></tr>
<tr class="memitem:aed9720006709538064f16b07ef71e3c1"><td class="memTemplParams" colspan="2"><a class="anchor" id="aed9720006709538064f16b07ef71e3c1"></a>
template&lt;class Csa &gt; </td></tr>
<tr class="memitem:aed9720006709538064f16b07ef71e3c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#aed9720006709538064f16b07ef71e3c1">test_lf_access</a> (const Csa &amp;csa, typename Csa::size_type times=1000000)</td></tr>
<tr class="memdesc:aed9720006709538064f16b07ef71e3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test random access on LF function. <br/></td></tr>
<tr class="memitem:a494be959d5fcc42fe305207c880000a7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a494be959d5fcc42fe305207c880000a7"></a>
template&lt;class Csa &gt; </td></tr>
<tr class="memitem:a494be959d5fcc42fe305207c880000a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a494be959d5fcc42fe305207c880000a7">test_bwt_access</a> (const Csa &amp;csa, typename Csa::size_type times=1000000)</td></tr>
<tr class="memdesc:a494be959d5fcc42fe305207c880000a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test random access on bwt. <br/></td></tr>
<tr class="memitem:a2b06bf66dc5e9728ec22722ea8380d8e"><td class="memTemplParams" colspan="2">template&lt;class Csa &gt; </td></tr>
<tr class="memitem:a2b06bf66dc5e9728ec22722ea8380d8e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a2b06bf66dc5e9728ec22722ea8380d8e">test_pattern_matching</a> (const Csa &amp;csa, const char *file_name, const typename Csa::size_type pattern_len=20, typename Csa::size_type times=1000000)</td></tr>
<tr class="memdesc:a2b06bf66dc5e9728ec22722ea8380d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test speed for pattern matching.  <a href="#a2b06bf66dc5e9728ec22722ea8380d8e"></a><br/></td></tr>
<tr class="memitem:a97b7d4991576c51b8668227b31c391a1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a97b7d4991576c51b8668227b31c391a1"></a>
template&lt;class Csa &gt; </td></tr>
<tr class="memitem:a97b7d4991576c51b8668227b31c391a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_rank_bwt_access</b> (const Csa &amp;csa, typename Csa::size_type times=1000000)</td></tr>
<tr class="memitem:a3e11a40bd14ba1b91108f97a09a8b1d7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3e11a40bd14ba1b91108f97a09a8b1d7"></a>
template&lt;class Csa &gt; </td></tr>
<tr class="memitem:a3e11a40bd14ba1b91108f97a09a8b1d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_select_bwt_access</b> (const Csa &amp;csa, typename Csa::size_type times=500000)</td></tr>
<tr class="memitem:a4c54f3213ceb3f9f9c99826f079d2e4b"><td class="memTemplParams" colspan="2">template&lt;class Cst &gt; </td></tr>
<tr class="memitem:a4c54f3213ceb3f9f9c99826f079d2e4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a4c54f3213ceb3f9f9c99826f079d2e4b">test_cst_dfs_iterator</a> (Cst &amp;cst, typename Cst::size_type times=100000)</td></tr>
<tr class="memdesc:a4c54f3213ceb3f9f9c99826f079d2e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test performance of the depth first iterator of a CST.  <a href="#a4c54f3213ceb3f9f9c99826f079d2e4b"></a><br/></td></tr>
<tr class="memitem:a9542fda142f4b3f2c0244245f8d67fd0"><td class="memTemplParams" colspan="2">template&lt;class Cst &gt; </td></tr>
<tr class="memitem:a9542fda142f4b3f2c0244245f8d67fd0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a9542fda142f4b3f2c0244245f8d67fd0">test_cst_dfs_iterator_and_depth</a> (Cst &amp;cst, typename Cst::size_type times=1000000, bool output=false)</td></tr>
<tr class="memdesc:a9542fda142f4b3f2c0244245f8d67fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test performance of the depth first iterator and the LCP array of a CST.  <a href="#a9542fda142f4b3f2c0244245f8d67fd0"></a><br/></td></tr>
<tr class="memitem:a4c4f1cb7fa2739eccd8b2ce9b6923734"><td class="memTemplParams" colspan="2">template&lt;class Cst &gt; </td></tr>
<tr class="memitem:a4c4f1cb7fa2739eccd8b2ce9b6923734"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a4c4f1cb7fa2739eccd8b2ce9b6923734">test_cst_dfs_iterator_and_id</a> (Cst &amp;cst, typename Cst::size_type times=1000000, bool output=false)</td></tr>
<tr class="memdesc:a4c4f1cb7fa2739eccd8b2ce9b6923734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test performance of the depth first iterator and the id method of the CST.  <a href="#a4c4f1cb7fa2739eccd8b2ce9b6923734"></a><br/></td></tr>
<tr class="memitem:a2f230731a5cde7f3a279dc96696d85ed"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2f230731a5cde7f3a279dc96696d85ed"></a>
template&lt;class Lcp &gt; </td></tr>
<tr class="memitem:a2f230731a5cde7f3a279dc96696d85ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a2f230731a5cde7f3a279dc96696d85ed">test_lcp_random_access</a> (Lcp &amp;lcp, typename Lcp::size_type times=10000000)</td></tr>
<tr class="memdesc:a2f230731a5cde7f3a279dc96696d85ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make random accesse to an LCP array. <br/></td></tr>
<tr class="memitem:a828748493020c4ba4d22c1dddf0d86c2"><td class="memTemplParams" colspan="2">template&lt;class Lcp &gt; </td></tr>
<tr class="memitem:a828748493020c4ba4d22c1dddf0d86c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a828748493020c4ba4d22c1dddf0d86c2">test_lcp_sequential_access</a> (Lcp &amp;lcp, typename Lcp::size_type times=10000000)</td></tr>
<tr class="memdesc:a828748493020c4ba4d22c1dddf0d86c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sequential accesses to an LCP array.  <a href="#a828748493020c4ba4d22c1dddf0d86c2"></a><br/></td></tr>
<tr class="memitem:ac5a4df7d86b576d54c32b81eb71da86b"><td class="memTemplParams" colspan="2">template&lt;class Lcp &gt; </td></tr>
<tr class="memitem:ac5a4df7d86b576d54c32b81eb71da86b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#ac5a4df7d86b576d54c32b81eb71da86b">test_lcp_random_sequential_access</a> (Lcp &amp;lcp, typename Lcp::size_type times=1000000, typename Lcp::size_type seq_len=64)</td></tr>
<tr class="memdesc:ac5a4df7d86b576d54c32b81eb71da86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make random sequential accesse to an LCP array.  <a href="#ac5a4df7d86b576d54c32b81eb71da86b"></a><br/></td></tr>
<tr class="memitem:a91911d2c2a0edcc1a49625fcb0f50040"><td class="memTemplParams" colspan="2">template&lt;class Cst &gt; </td></tr>
<tr class="memitem:a91911d2c2a0edcc1a49625fcb0f50040"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a91911d2c2a0edcc1a49625fcb0f50040">test_cst_parent_operation</a> (const Cst &amp;cst, typename Cst::size_type times=100000, uint64_t x=17)</td></tr>
<tr class="memdesc:a91911d2c2a0edcc1a49625fcb0f50040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the speed of the parent operation.  <a href="#a91911d2c2a0edcc1a49625fcb0f50040"></a><br/></td></tr>
<tr class="memitem:a02ad999788274a8e73f4e3a1807912cf"><td class="memTemplParams" colspan="2">template&lt;class Cst &gt; </td></tr>
<tr class="memitem:a02ad999788274a8e73f4e3a1807912cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a02ad999788274a8e73f4e3a1807912cf">generate_nodes_from_random_leaves</a> (const Cst &amp;cst, typename Cst::size_type times, std::vector&lt; typename Cst::node_type &gt; &amp;nodes, uint64_t x=17)</td></tr>
<tr class="memdesc:a02ad999788274a8e73f4e3a1807912cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate nodes of a cst by applying the child operation to each of <img class="formulaInl" alt="$times$" src="form_233.png"/> random leaves until we get to the root.  <a href="#a02ad999788274a8e73f4e3a1807912cf"></a><br/></td></tr>
<tr class="memitem:a0604c9f7ef1bac0ae4281e6a76266f0d"><td class="memTemplParams" colspan="2">template&lt;class Cst &gt; </td></tr>
<tr class="memitem:a0604c9f7ef1bac0ae4281e6a76266f0d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a0604c9f7ef1bac0ae4281e6a76266f0d">test_cst_child_operation</a> (const Cst &amp;cst, typename Cst::size_type times=5000, uint64_t x=17)</td></tr>
<tr class="memdesc:a0604c9f7ef1bac0ae4281e6a76266f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the speed of the child operation.  <a href="#a0604c9f7ef1bac0ae4281e6a76266f0d"></a><br/></td></tr>
<tr class="memitem:a19e5ba782e1fd2cf1dd91ba2fe8407a4"><td class="memTemplParams" colspan="2">template&lt;class Cst &gt; </td></tr>
<tr class="memitem:a19e5ba782e1fd2cf1dd91ba2fe8407a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a19e5ba782e1fd2cf1dd91ba2fe8407a4">test_cst_1th_child_operation</a> (const Cst &amp;cst, typename Cst::size_type times=1000000, uint64_t x=17)</td></tr>
<tr class="memdesc:a19e5ba782e1fd2cf1dd91ba2fe8407a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the speed of the 1th_child operation.  <a href="#a19e5ba782e1fd2cf1dd91ba2fe8407a4"></a><br/></td></tr>
<tr class="memitem:ad0b9442289b5561a858091faf7edeffc"><td class="memTemplParams" colspan="2">template&lt;class Cst &gt; </td></tr>
<tr class="memitem:ad0b9442289b5561a858091faf7edeffc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#ad0b9442289b5561a858091faf7edeffc">test_cst_sibling_operation</a> (const Cst &amp;cst, typename Cst::size_type times=100000, uint64_t x=17)</td></tr>
<tr class="memdesc:ad0b9442289b5561a858091faf7edeffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the speed of the sibling operation.  <a href="#ad0b9442289b5561a858091faf7edeffc"></a><br/></td></tr>
<tr class="memitem:adf3990babf5e11924f64354c3d476a62"><td class="memTemplParams" colspan="2"><a class="anchor" id="adf3990babf5e11924f64354c3d476a62"></a>
template&lt;class Cst &gt; </td></tr>
<tr class="memitem:adf3990babf5e11924f64354c3d476a62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#adf3990babf5e11924f64354c3d476a62">test_cst_id_operation</a> (const Cst &amp;cst, typename Cst::size_type times=100000, uint64_t x=17)</td></tr>
<tr class="memdesc:adf3990babf5e11924f64354c3d476a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test id operation. <br/></td></tr>
<tr class="memitem:a55e855ee18ca7c268cd4ee521ec4c40e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a55e855ee18ca7c268cd4ee521ec4c40e"></a>
template&lt;class Cst &gt; </td></tr>
<tr class="memitem:a55e855ee18ca7c268cd4ee521ec4c40e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a55e855ee18ca7c268cd4ee521ec4c40e">test_cst_depth_operation</a> (const Cst &amp;cst, typename Cst::size_type times=100000, uint64_t x=17)</td></tr>
<tr class="memdesc:a55e855ee18ca7c268cd4ee521ec4c40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test depth operations for leaves and inner nodes. <br/></td></tr>
<tr class="memitem:a15aaccb1935c85aa416037f8b2ed5861"><td class="memTemplParams" colspan="2"><a class="anchor" id="a15aaccb1935c85aa416037f8b2ed5861"></a>
template&lt;class Cst &gt; </td></tr>
<tr class="memitem:a15aaccb1935c85aa416037f8b2ed5861"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a15aaccb1935c85aa416037f8b2ed5861">test_cst_depth_operation_for_inner_nodes</a> (const Cst &amp;cst, typename Cst::size_type times=100000, uint64_t x=17)</td></tr>
<tr class="memdesc:a15aaccb1935c85aa416037f8b2ed5861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test depth operations for inner nodes. <br/></td></tr>
<tr class="memitem:a2d78a9c5225268dfbd27ea83995d7b5d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2d78a9c5225268dfbd27ea83995d7b5d"></a>
template&lt;class Cst &gt; </td></tr>
<tr class="memitem:a2d78a9c5225268dfbd27ea83995d7b5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a2d78a9c5225268dfbd27ea83995d7b5d">test_cst_lca_operation</a> (const Cst &amp;cst, typename Cst::size_type times=1000000, uint64_t x=17)</td></tr>
<tr class="memdesc:a2d78a9c5225268dfbd27ea83995d7b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test lca operation. <br/></td></tr>
<tr class="memitem:a9183e3976fd1d4fb34017b0ebf4f543d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9183e3976fd1d4fb34017b0ebf4f543d"></a>
template&lt;class Cst &gt; </td></tr>
<tr class="memitem:a9183e3976fd1d4fb34017b0ebf4f543d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a9183e3976fd1d4fb34017b0ebf4f543d">test_cst_sl_operation</a> (const Cst &amp;cst, typename Cst::size_type times=500, uint64_t x=17)</td></tr>
<tr class="memdesc:a9183e3976fd1d4fb34017b0ebf4f543d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test suffix link operation. <br/></td></tr>
<tr class="memitem:a8a1b1ea4e6dc58b2f90259bf9898c122"><td class="memTemplParams" colspan="2">template&lt;class Cst &gt; </td></tr>
<tr class="memitem:a8a1b1ea4e6dc58b2f90259bf9898c122"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a8a1b1ea4e6dc58b2f90259bf9898c122">test_cst_matching_statistics</a> (const Cst &amp;cst, unsigned char *S2, typename Cst::size_type n2)</td></tr>
<tr class="memdesc:a8a1b1ea4e6dc58b2f90259bf9898c122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test matching statistics.  <a href="#a8a1b1ea4e6dc58b2f90259bf9898c122"></a><br/></td></tr>
<tr class="memitem:a5e2ea1602a03798447641a1b02e25ac3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5e2ea1602a03798447641a1b02e25ac3"></a>
template&lt;class Bps &gt; </td></tr>
<tr class="memitem:a5e2ea1602a03798447641a1b02e25ac3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_bps_find_close_and_enclose</b> (const Bps &amp;bps, const <a class="el" href="a00285.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;b, uint64_t times=10000000, uint64_t x=17)</td></tr>
<tr class="memitem:a5e1fb7cf15f5c30dddb6d2ec677407d7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5e1fb7cf15f5c30dddb6d2ec677407d7"></a>
template&lt;class Bps &gt; </td></tr>
<tr class="memitem:a5e1fb7cf15f5c30dddb6d2ec677407d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_bps_find_open</b> (const Bps &amp;bps, const <a class="el" href="a00285.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;b, uint64_t times=10000000, uint64_t x=17)</td></tr>
<tr class="memitem:af112ac8fd45f90ad28ca581b92c04ade"><td class="memTemplParams" colspan="2"><a class="anchor" id="af112ac8fd45f90ad28ca581b92c04ade"></a>
template&lt;class Bps &gt; </td></tr>
<tr class="memitem:af112ac8fd45f90ad28ca581b92c04ade"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_bps_double_enclose</b> (const Bps &amp;bps, const <a class="el" href="a00285.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;b, uint64_t times=10000000, uint64_t x=17)</td></tr>
<tr class="memitem:a478f5f7db45f61644d75e6c664bd961e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a478f5f7db45f61644d75e6c664bd961e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00285.html#a478f5f7db45f61644d75e6c664bd961e">write_R_output</a> (std::string data_structure, std::string action, std::string state=&quot;begin&quot;, uint64_t times=1, uint64_t check=0)</td></tr>
<tr class="memdesc:a478f5f7db45f61644d75e6c664bd961e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write stopwatch output in readable format. <br/></td></tr>
<tr class="memitem:aefc1d0d878b0085abeb34ec28dde3c22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefc1d0d878b0085abeb34ec28dde3c22"></a>
off_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00285.html#aefc1d0d878b0085abeb34ec28dde3c22">get_file_size</a> (const char *file_name)</td></tr>
<tr class="memdesc:aefc1d0d878b0085abeb34ec28dde3c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a file in bytes. <br/></td></tr>
<tr class="memitem:ac879958403162b91c5c7a7e32ea5ae95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac879958403162b91c5c7a7e32ea5ae95"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>begin_tikzpicture</b> (ostream &amp;out, string options=&quot;&quot;)</td></tr>
<tr class="memitem:a1a86525a66df40da388bc37a5d67ed24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a86525a66df40da388bc37a5d67ed24"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>end_tikzpicture</b> (ostream &amp;out)</td></tr>
<tr class="memitem:a28347826c82090422d5a2e8eca7f7861"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28347826c82090422d5a2e8eca7f7861"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>begin_tikzscope</b> (ostream &amp;out, string options=&quot;&quot;)</td></tr>
<tr class="memitem:a4840278bf6933d2e811da7f17b453016"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4840278bf6933d2e811da7f17b453016"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>end_tikzscope</b> (ostream &amp;out)</td></tr>
<tr class="memitem:a8449d9f2794f8452cf322214d5555ad5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8449d9f2794f8452cf322214d5555ad5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tikz_node</b> (ostream &amp;out, string content=&quot;&quot;, string at=&quot;0,0&quot;, string name=&quot;&quot;, string options=&quot;&quot;)</td></tr>
<tr class="memitem:af10e7fe569376c32f766c73dd0194097"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af10e7fe569376c32f766c73dd0194097"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tikz_coordinate</b> (ostream &amp;out, string at=&quot;0,0&quot;, string name=&quot;&quot;, string option=&quot;&quot;)</td></tr>
<tr class="memitem:a4dea4cad529c6fb8ab89fc44297e977c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4dea4cad529c6fb8ab89fc44297e977c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4dea4cad529c6fb8ab89fc44297e977c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>write_tikz_column_from_container</b> (ostream &amp;out, const T &amp;vec, string name_prefix=&quot;i&quot;)</td></tr>
<tr class="memitem:aa732b7154c3b4237ef7baa7aa8ce223e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa732b7154c3b4237ef7baa7aa8ce223e"></a>
template&lt;class tContainer &gt; </td></tr>
<tr class="memitem:aa732b7154c3b4237ef7baa7aa8ce223e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>write_tikz_array</b> (ostream &amp;out, const tContainer &amp;v, string array_name=&quot;&quot;, bool escape=false)</td></tr>
<tr class="memitem:a6ebe4eba97be9f3a4f1440b3159022d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ebe4eba97be9f3a4f1440b3159022d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>write_y_column</b> (ostream &amp;out, size_t n)</td></tr>
<tr class="memitem:ab8567dd79c2d725af8f71e05d9c8f82b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8567dd79c2d725af8f71e05d9c8f82b"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const uint128_t &amp;x)</td></tr>
<tr class="memitem:a8ed9a3303718a1ba92d9f84bba83fffc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ed9a3303718a1ba92d9f84bba83fffc"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a00171.html">uint256_t</a> &amp;x)</td></tr>
<tr class="memitem:a4af7e3d1d37c1645e07c0de48c0d73d2"><td class="memTemplParams" colspan="2">template&lt;class size_type_class , class size_type &gt; </td></tr>
<tr class="memitem:a4af7e3d1d37c1645e07c0de48c0d73d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#a4af7e3d1d37c1645e07c0de48c0d73d2">calculate_character_occurences</a> (<a class="el" href="a00070.html">int_vector_file_buffer</a>&lt; 8, size_type_class &gt; &amp;text, const size_type size, size_type *C)</td></tr>
<tr class="memdesc:a4af7e3d1d37c1645e07c0de48c0d73d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count for each character in [0..255] the number of occurences in rac[0..size-1].  <a href="#a4af7e3d1d37c1645e07c0de48c0d73d2"></a><br/></td></tr>
<tr class="memitem:aabaa9b09015e7fb1b71493562cf558f5"><td class="memTemplParams" colspan="2"><a class="anchor" id="aabaa9b09015e7fb1b71493562cf558f5"></a>
template&lt;class size_type &gt; </td></tr>
<tr class="memitem:aabaa9b09015e7fb1b71493562cf558f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>calculate_effective_alphabet_size</b> (const size_type *C, size_type &amp;sigma)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a15caa2cf9a468eaabf7352b5cd021799"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15caa2cf9a468eaabf7352b5cd021799"></a>
const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>_undef_node</b> = 65535</td></tr>
<tr class="memitem:a1c342c78e904e09a64c927273f7bc491"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c342c78e904e09a64c927273f7bc491"></a>
const int_vector::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>ZoO</b> [2] = {0, (<a class="el" href="a00068.html">int_vector</a>&lt;&gt;::size_type)-1}</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Namespace for the succinct data structure library. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a4af7e3d1d37c1645e07c0de48c0d73d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class size_type_class , class size_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00285.html#a4af7e3d1d37c1645e07c0de48c0d73d2">sdsl::calculate_character_occurences</a> </td>
          <td>(</td>
          <td class="paramtype">int_vector_file_buffer&lt; 8, size_type_class &gt; &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type *&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Count for each character in [0..255] the number of occurences in rac[0..size-1]. </p>
<dl class="section return"><dt>Returns:</dt><dd>C An array of size 256, which contains for each character the number of occurences in rac[0..size-1] </dd></dl>

</div>
</div>
<a class="anchor" id="a396b6b833af2ec71736f28b65b23e605"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00285.html#a396b6b833af2ec71736f28b65b23e605">sdsl::construct_bwt</a> </td>
          <td>(</td>
          <td class="paramtype">tMSS &amp;&#160;</td>
          <td class="paramname"><em>file_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructs the Burrows and Wheeler Transform (BWT) from text and suffix array </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">file_map</td><td>A map, which contains the paths of the precalculated files like suffix array or text </td></tr>
    <tr><td class="paramname">dir</td><td>Directory in which the result should be written on disk. </td></tr>
    <tr><td class="paramname">id</td><td>Id which should be used to build a file name for the calculated BWT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Space complexity:</b></dt><dd><img class="formulaInl" alt="$n$" src="form_20.png"/> bytes </dd></dl>

</div>
</div>
<a class="anchor" id="a4a5f92e46f9ed01d3bb74787146bbfaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00285.html#a4a5f92e46f9ed01d3bb74787146bbfaf">sdsl::construct_cst</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cst &amp;&#160;</td>
          <td class="paramname"><em>cst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a compressed suffix tree (cst) by a semi-external algorithm. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>File name of the text, for which the cst should be build </td></tr>
    <tr><td class="paramname">cst</td><td>A reference to the cst object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Details</b></dt><dd>The semi-external construction algorithm creates some temporary files in the current directory during the calculation.</dd></dl>
<dl class="section user"><dt>Space complexity</b></dt><dd><img class="formulaInl" alt="$5n$" src="form_132.png"/> bytes </dd></dl>
<dl class="section user"><dt>Time complexity</b></dt><dd><img class="formulaInl" alt="$\Order{n}$" src="form_29.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="a4f261e33bcd712b64dc413089d6ddfa8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00285.html#a4a5f92e46f9ed01d3bb74787146bbfaf">sdsl::construct_cst</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cst &amp;&#160;</td>
          <td class="paramname"><em>cst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tMSS &amp;&#160;</td>
          <td class="paramname"><em>file_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delete_files</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dir</em> = <code>&quot;./&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>build_only_bps</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>lcp_method</em> = <code>&quot;any&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a compressed suffix tree (cst) semi-external. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>File name of the text, for which the cst should be build </td></tr>
    <tr><td class="paramname">cst</td><td>A reference to the cst object. cst will hold the result after the execution of the method. </td></tr>
    <tr><td class="paramname">file_map</td><td>A map which will contain the file names of structures which are calculated and stored during the construction. </td></tr>
    <tr><td class="paramname">delete_files</td><td>Boolean flag. If it is true, all files stored in file_map will be removed after the construction. </td></tr>
    <tr><td class="paramname">dir</td><td>A directory path which points to the directory where the calculated files should be stored during the construction. </td></tr>
    <tr><td class="paramname">build_only_bps</td><td>Boolean flag. If it is true, only the navigation part of the cst is build. I.e. compressed suffix array and other stuff is ommitted... </td></tr>
    <tr><td class="paramname">lcp_method</td><td>Specify, which lcp construction algorithm should be used. Possible options are kasai, PHI, go, go2, any</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Space complexity</b></dt><dd><img class="formulaInl" alt="$5n$" src="form_132.png"/> bytes </dd></dl>
<dl class="section user"><dt>Time complexity</b></dt><dd><img class="formulaInl" alt="$\Order{n}$" src="form_29.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="aab2eca3099c5d212934bcfddd54261a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00285.html#aab2eca3099c5d212934bcfddd54261a4">sdsl::construct_lcp_go</a> </td>
          <td>(</td>
          <td class="paramtype">tMSS &amp;&#160;</td>
          <td class="paramname"><em>file_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Our new 2 phases lcp algorithm using usually 2n bytes. </p>
<div class="fragment"><pre class="fragment">  The algorithm computes the lcp array and stores it to disk.
</pre></div> <dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">file_map</td><td>A map which contains the filenames of previous computed structures (like suffix array, Burrows and Wheeler transform, inverse suffix array, text,...) </td></tr>
    <tr><td class="paramname">dir</td><td>Directory where the lcp array should be stored. </td></tr>
    <tr><td class="paramname">id</td><td>Id for the file name of the lcp array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Space complexity</b></dt><dd>Usually <img class="formulaInl" alt="$ 2n $" src="form_176.png"/> bytes, worst case <img class="formulaInl" alt="$5n bytes$" src="form_177.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="aa99d7a193bf9889994ef8bc1cb3da646"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00285.html#aa99d7a193bf9889994ef8bc1cb3da646">sdsl::construct_lcp_go2</a> </td>
          <td>(</td>
          <td class="paramtype">tMSS &amp;&#160;</td>
          <td class="paramname"><em>file_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Our new 2 phases lcp algorithm using usually 1 n bytes. </p>
<div class="fragment"><pre class="fragment">  The algorithm computes the lcp array and stores it to disk.
</pre></div> <dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">file_map</td><td>A map which contains the filenames of previous computed structures (like suffix array, Burrows and Wheeler transform, inverse suffix array, text,...) </td></tr>
    <tr><td class="paramname">dir</td><td>Directory where the lcp array should be stored. </td></tr>
    <tr><td class="paramname">id</td><td>Id for the file name of the lcp array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Space complexity:</b></dt><dd>Usually <img class="formulaInl" alt="$ n+\Order{1} $" src="form_178.png"/> bytes, worst case <img class="formulaInl" alt="$ 5n $" src="form_174.png"/> bytes </dd></dl>

</div>
</div>
<a class="anchor" id="a0c672fbb78beb8b55ec3bfd763f7365a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00285.html#a0c672fbb78beb8b55ec3bfd763f7365a">sdsl::construct_lcp_goPHI</a> </td>
          <td>(</td>
          <td class="paramtype">tMSS &amp;&#160;</td>
          <td class="paramname"><em>file_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Our new 2 phases lcp algorithm using usually 2n bytes. </p>
<div class="fragment"><pre class="fragment">  The algorithm computes the lcp array and stores it to disk.
</pre></div> <dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">file_map</td><td>A map which contains the filenames of previous computed structures (like suffix array, Burrows and Wheeler transform, inverse suffix array, text,...) </td></tr>
    <tr><td class="paramname">dir</td><td>Directory where the lcp array should be stored. </td></tr>
    <tr><td class="paramname">id</td><td>Id for the file name of the lcp array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Space complexity</b></dt><dd>Usually <img class="formulaInl" alt="$ 2n $" src="form_176.png"/> bytes, worst case <img class="formulaInl" alt="$5n bytes$" src="form_177.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="a3daccd09d4dbb93edd609e31377228de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00285.html#a3daccd09d4dbb93edd609e31377228de">sdsl::construct_lcp_kasai</a> </td>
          <td>(</td>
          <td class="paramtype">tMSS &amp;&#160;</td>
          <td class="paramname"><em>file_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>5n byte variant of the algorithm of Kasai et al. (CPM 2001, "Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its Applications") </p>
<div class="fragment"><pre class="fragment">   The algorithm computes the lcp array and stores it to disk.
</pre></div> <dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">file_map</td><td>A map which contains the filenames of previous computed structures (like suffix array, Burrows and Wheeler transform, inverse suffix array, text,...) </td></tr>
    <tr><td class="paramname">dir</td><td>Directory where the lcp array should be stored. </td></tr>
    <tr><td class="paramname">id</td><td>Id for the file name of the lcp array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Space complexity</b></dt><dd><img class="formulaInl" alt="$ 5n $" src="form_174.png"/> bytes </dd></dl>

</div>
</div>
<a class="anchor" id="a34d793ed42593dc3d878662668c57b14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00285.html#a34d793ed42593dc3d878662668c57b14">sdsl::construct_lcp_PHI</a> </td>
          <td>(</td>
          <td class="paramtype">tMSS &amp;&#160;</td>
          <td class="paramname"><em>file_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>semi_external</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>5n byte variant of the algorithm of Kaerkkaeinen et al. (CPM 2009, "Permuted Longest Common Prefix Array") </p>
<div class="fragment"><pre class="fragment">   The algorithm computes the lcp array and stores it to disk.
</pre></div> <dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">file_map</td><td>A map which contains the filenames of previous computed structures (like suffix array, Burrows and Wheeler transform, inverse suffix array, text,...) </td></tr>
    <tr><td class="paramname">dir</td><td>Directory where the lcp array should be stored. </td></tr>
    <tr><td class="paramname">id</td><td>Id for the file name of the lcp array. </td></tr>
    <tr><td class="paramname">semi_external</td><td>Boolean flag, which indicates if the algorithm should use only 4n bytes or 5n bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Space complexity</b></dt><dd><img class="formulaInl" alt="$ 5n $" src="form_174.png"/> bytes or <img class="formulaInl" alt="$ 4n $" src="form_175.png"/> bytes if semi_external is set to true </dd></dl>

</div>
</div>
<a class="anchor" id="a02ad999788274a8e73f4e3a1807912cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00285.html#a02ad999788274a8e73f4e3a1807912cf">sdsl::generate_nodes_from_random_leaves</a> </td>
          <td>(</td>
          <td class="paramtype">const Cst &amp;&#160;</td>
          <td class="paramname"><em>cst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::size_type&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename Cst::node_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em> = <code>17</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate nodes of a cst by applying the child operation to each of <img class="formulaInl" alt="$times$" src="form_233.png"/> random leaves until we get to the root. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">Cst</td><td>The compressed suffix </td></tr>
    <tr><td class="paramname">times</td><td>Numer of random leaves </td></tr>
    <tr><td class="paramname">nodes</td><td>Reference to a vector which will contain the generated nodes </td></tr>
    <tr><td class="paramname">x</td><td>Seed for the random number generator for the generation of the leaves </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac80054ed6a03880ca9d4065ffe3f6c0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tCst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="a00285.html#ac80054ed6a03880ca9d4065ffe3f6c0a">sdsl::H0</a> </td>
          <td>(</td>
          <td class="paramtype">const typename tCst::node_type &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tCst &amp;&#160;</td>
          <td class="paramname"><em>cst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the zeroth order entropy of the text that follows a certain substring s. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A suffix tree node v. The label of the path from the root to v is s. </td></tr>
    <tr><td class="paramname">cst</td><td>The suffix tree of v. </td></tr>
    <tr><td class="paramname">The</td><td>zeroth order entropy of the concatenation of all characters that follow s in the original text. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab60aeaabd7287956f8cfccdb34d71f8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tCst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="a00285.html#ab60aeaabd7287956f8cfccdb34d71f8d">sdsl::Hk</a> </td>
          <td>(</td>
          <td class="paramtype">const tCst &amp;&#160;</td>
          <td class="paramname"><em>cst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename tCst::size_type&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename tCst::size_type &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the k-th order entropy of a text. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cst</td><td>The suffix tree of v. </td></tr>
    <tr><td class="paramname">k</td><td>Parameter k for which H_k should be calculated. </td></tr>
    <tr><td class="paramname">context</td><td>A output reference which will hold the number of different contexts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19e5ba782e1fd2cf1dd91ba2fe8407a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00285.html#a19e5ba782e1fd2cf1dd91ba2fe8407a4">sdsl::test_cst_1th_child_operation</a> </td>
          <td>(</td>
          <td class="paramtype">const Cst &amp;&#160;</td>
          <td class="paramname"><em>cst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::size_type&#160;</td>
          <td class="paramname"><em>times</em> = <code>1000000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em> = <code>17</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test the speed of the 1th_child operation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">Cst</td><td>The compressed suffix tree </td></tr>
    <tr><td class="paramname">times</td><td>Number of times a traversal from a random leaf to the root\ is started to collect nodes for which the child operation is performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0604c9f7ef1bac0ae4281e6a76266f0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00285.html#a0604c9f7ef1bac0ae4281e6a76266f0d">sdsl::test_cst_child_operation</a> </td>
          <td>(</td>
          <td class="paramtype">const Cst &amp;&#160;</td>
          <td class="paramname"><em>cst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::size_type&#160;</td>
          <td class="paramname"><em>times</em> = <code>5000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em> = <code>17</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test the speed of the child operation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">Cst</td><td>The compressed suffix tree </td></tr>
    <tr><td class="paramname">times</td><td>Number of times a traversal from a random leaf to the root\ is started to collect nodes for which the child operation is performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c54f3213ceb3f9f9c99826f079d2e4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00285.html#a4c54f3213ceb3f9f9c99826f079d2e4b">sdsl::test_cst_dfs_iterator</a> </td>
          <td>(</td>
          <td class="paramtype">Cst &amp;&#160;</td>
          <td class="paramname"><em>cst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::size_type&#160;</td>
          <td class="paramname"><em>times</em> = <code>100000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test performance of the depth first iterator of a CST. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cst</td><td>The CST that should be tested. </td></tr>
    <tr><td class="paramname">times</td><td>The number of times the depth first iterator should be incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Details</b></dt><dd>This method increments the depth first search iterator of a CST n times. </dd></dl>

</div>
</div>
<a class="anchor" id="a9542fda142f4b3f2c0244245f8d67fd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00285.html#a9542fda142f4b3f2c0244245f8d67fd0">sdsl::test_cst_dfs_iterator_and_depth</a> </td>
          <td>(</td>
          <td class="paramtype">Cst &amp;&#160;</td>
          <td class="paramname"><em>cst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::size_type&#160;</td>
          <td class="paramname"><em>times</em> = <code>1000000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>output</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test performance of the depth first iterator and the LCP array of a CST. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cst</td><td>The CST that should be tested. </td></tr>
    <tr><td class="paramname">times</td><td>The number of times the depth first iterator should be incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Details</b></dt><dd>This method increments the depth first search iterator of a CST n times and calculates the depth for each visited node. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c4f1cb7fa2739eccd8b2ce9b6923734"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00285.html#a4c4f1cb7fa2739eccd8b2ce9b6923734">sdsl::test_cst_dfs_iterator_and_id</a> </td>
          <td>(</td>
          <td class="paramtype">Cst &amp;&#160;</td>
          <td class="paramname"><em>cst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::size_type&#160;</td>
          <td class="paramname"><em>times</em> = <code>1000000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>output</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test performance of the depth first iterator and the id method of the CST. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cst</td><td>The CST that should be tested. </td></tr>
    <tr><td class="paramname">times</td><td>The number of times the depth first iterator should be incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Details</b></dt><dd>This method increments the depth first search iterator of a CST n times and calculates the function id for each visited node. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a1b1ea4e6dc58b2f90259bf9898c122"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00285.html#a8a1b1ea4e6dc58b2f90259bf9898c122">sdsl::test_cst_matching_statistics</a> </td>
          <td>(</td>
          <td class="paramtype">const Cst &amp;&#160;</td>
          <td class="paramname"><em>cst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>S2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::size_type&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test matching statistics. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cst</td><td>Compressed suffix tree of sequence S1 of length n1 </td></tr>
    <tr><td class="paramname">S2</td><td>Pointer to the unsigned char array S2. </td></tr>
    <tr><td class="paramname">n2</td><td>The length of S2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91911d2c2a0edcc1a49625fcb0f50040"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00285.html#a91911d2c2a0edcc1a49625fcb0f50040">sdsl::test_cst_parent_operation</a> </td>
          <td>(</td>
          <td class="paramtype">const Cst &amp;&#160;</td>
          <td class="paramname"><em>cst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::size_type&#160;</td>
          <td class="paramname"><em>times</em> = <code>100000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em> = <code>17</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test the speed of the parent operation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">Cst</td><td>The compressed suffix tree </td></tr>
    <tr><td class="paramname">times</td><td>Number of times a traversal from a random leaf to the root\ is started to collect nodes for which the parent operation is performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0b9442289b5561a858091faf7edeffc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00285.html#ad0b9442289b5561a858091faf7edeffc">sdsl::test_cst_sibling_operation</a> </td>
          <td>(</td>
          <td class="paramtype">const Cst &amp;&#160;</td>
          <td class="paramname"><em>cst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Cst::size_type&#160;</td>
          <td class="paramname"><em>times</em> = <code>100000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em> = <code>17</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test the speed of the sibling operation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">Cst</td><td>The compressed suffix tree </td></tr>
    <tr><td class="paramname">times</td><td>Number of times a traversal from a random leaf to the root\ is started to collect nodes for which the child operation is performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5a4df7d86b576d54c32b81eb71da86b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Lcp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00285.html#ac5a4df7d86b576d54c32b81eb71da86b">sdsl::test_lcp_random_sequential_access</a> </td>
          <td>(</td>
          <td class="paramtype">Lcp &amp;&#160;</td>
          <td class="paramname"><em>lcp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Lcp::size_type&#160;</td>
          <td class="paramname"><em>times</em> = <code>1000000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Lcp::size_type&#160;</td>
          <td class="paramname"><em>seq_len</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make random sequential accesse to an LCP array. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lcp</td><td>The lcp data structure </td></tr>
    <tr><td class="paramname">times</td><td>The number of random accesses </td></tr>
    <tr><td class="paramname">seq_len</td><td>The number of sequential accesses after each random access This test was described in the master thesis of Rodrigo Canovas. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a828748493020c4ba4d22c1dddf0d86c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Lcp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00285.html#a828748493020c4ba4d22c1dddf0d86c2">sdsl::test_lcp_sequential_access</a> </td>
          <td>(</td>
          <td class="paramtype">Lcp &amp;&#160;</td>
          <td class="paramname"><em>lcp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Lcp::size_type&#160;</td>
          <td class="paramname"><em>times</em> = <code>10000000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make sequential accesses to an LCP array. </p>
<p>The access time for lcp sequential access is not important in practice, as sequential access should be realized by streaming the uncompressed lcp array from disk. </p>

</div>
</div>
<a class="anchor" id="a2b06bf66dc5e9728ec22722ea8380d8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00285.html#a2b06bf66dc5e9728ec22722ea8380d8e">sdsl::test_pattern_matching</a> </td>
          <td>(</td>
          <td class="paramtype">const Csa &amp;&#160;</td>
          <td class="paramname"><em>csa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Csa::size_type&#160;</td>
          <td class="paramname"><em>pattern_len</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Csa::size_type&#160;</td>
          <td class="paramname"><em>times</em> = <code>1000000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test speed for pattern matching. </p>
<dl class="section user"><dt>Selection of patterns: The pattern are selected from</b></dt><dd>random position in the original Do we really need file_name? We can also extract text from the csa... </dd></dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 13 2012 15:23:28 for SDSL: Succinct Data Structure Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
