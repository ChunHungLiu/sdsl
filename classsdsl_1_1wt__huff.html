<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>SDSL: Succinct Data Structure Library: sdsl::wt_huff&lt; BitVector, RankSupport, SelectSupport, SelectSupportZero, dfs_shape &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">SDSL: Succinct Data Structure Library
   
   </div>
   <div id="projectbrief">A C++ template library for succinct data structures</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacesdsl.html">sdsl</a>      </li>
      <li class="navelem"><a class="el" href="classsdsl_1_1wt__huff.html">wt_huff</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">sdsl::wt_huff&lt; BitVector, RankSupport, SelectSupport, SelectSupportZero, dfs_shape &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__wt.html">Wavelet Trees (WT)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A Wavelet Tree class for byte sequences.  
 <a href="classsdsl_1_1wt__huff.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="wt__huff_8hpp_source.html">wt_huff.hpp</a>&gt;</code></p>

<p><a href="classsdsl_1_1wt__huff-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aeb4de5269a4edc3195ca80136bdf1c10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb4de5269a4edc3195ca80136bdf1c10"></a>
typedef int_vector::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="memitem:ab95f5ef14df527c8f87adc3a21283019"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab95f5ef14df527c8f87adc3a21283019"></a>
typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="memitem:ac17544758a8110782762df20a761fc40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac17544758a8110782762df20a761fc40"></a>
typedef BitVector&#160;</td><td class="memItemRight" valign="bottom"><b>bit_vector_type</b></td></tr>
<tr class="memitem:a2f46db857678d2d33cfada238fd85be1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f46db857678d2d33cfada238fd85be1"></a>
typedef RankSupport&#160;</td><td class="memItemRight" valign="bottom"><b>rank_1_type</b></td></tr>
<tr class="memitem:ad7642c803430436ef22f4ea9c7f647db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7642c803430436ef22f4ea9c7f647db"></a>
typedef SelectSupport&#160;</td><td class="memItemRight" valign="bottom"><b>select_1_type</b></td></tr>
<tr class="memitem:acd8da0ca03bfc1912c883a0cff8b0373"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd8da0ca03bfc1912c883a0cff8b0373"></a>
typedef SelectSupportZero&#160;</td><td class="memItemRight" valign="bottom"><b>select_0_type</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a788cf767698999e8619b51640dff93fe"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessContainer &gt; </td></tr>
<tr class="memitem:a788cf767698999e8619b51640dff93fe"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsdsl_1_1wt__huff.html#a788cf767698999e8619b51640dff93fe">wt_huff</a> (const RandomAccessContainer &amp;rac, size_type <a class="el" href="classsdsl_1_1wt__huff.html#ae458886ca5901fafaffde73375ac8e32">size</a>)</td></tr>
<tr class="memdesc:a788cf767698999e8619b51640dff93fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a788cf767698999e8619b51640dff93fe"></a><br/></td></tr>
<tr class="memitem:a90451a105978382a4b9fe931c550374f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a90451a105978382a4b9fe931c550374f"></a>
template&lt;uint8_t w&gt; </td></tr>
<tr class="memitem:a90451a105978382a4b9fe931c550374f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wt_huff</b> (const <a class="el" href="classsdsl_1_1int__vector.html">int_vector</a>&lt; w &gt; &amp;rac)</td></tr>
<tr class="memitem:a5facfc49090e1ad73c92d63ca5828a3e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5facfc49090e1ad73c92d63ca5828a3e"></a>
template&lt;typename RandomAccessContainer &gt; </td></tr>
<tr class="memitem:a5facfc49090e1ad73c92d63ca5828a3e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>construct</b> (const RandomAccessContainer &amp;rac, size_type <a class="el" href="classsdsl_1_1wt__huff.html#ae458886ca5901fafaffde73375ac8e32">size</a>)</td></tr>
<tr class="memitem:a9d547a9a37ae54e8de8c0a6b905732b9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9d547a9a37ae54e8de8c0a6b905732b9"></a>
template&lt;class size_type_class &gt; </td></tr>
<tr class="memitem:a9d547a9a37ae54e8de8c0a6b905732b9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wt_huff</b> (<a class="el" href="classsdsl_1_1int__vector__file__buffer.html">int_vector_file_buffer</a>&lt; 8, size_type_class &gt; &amp;rac, size_type <a class="el" href="classsdsl_1_1wt__huff.html#ae458886ca5901fafaffde73375ac8e32">size</a>)</td></tr>
<tr class="memitem:a19819fd81f6f6e4f0bfaf2129f5c50e8"><td class="memTemplParams" colspan="2">template&lt;class size_type_class &gt; </td></tr>
<tr class="memitem:a19819fd81f6f6e4f0bfaf2129f5c50e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsdsl_1_1wt__huff.html#a19819fd81f6f6e4f0bfaf2129f5c50e8">construct</a> (<a class="el" href="classsdsl_1_1int__vector__file__buffer.html">int_vector_file_buffer</a>&lt; 8, size_type_class &gt; &amp;rac, size_type <a class="el" href="classsdsl_1_1wt__huff.html#ae458886ca5901fafaffde73375ac8e32">size</a>)</td></tr>
<tr class="memdesc:a19819fd81f6f6e4f0bfaf2129f5c50e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the wavelet tree from a random access container.  <a href="#a19819fd81f6f6e4f0bfaf2129f5c50e8"></a><br/></td></tr>
<tr class="memitem:a325a462def35f8bc21747d3c6ea0edf2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a325a462def35f8bc21747d3c6ea0edf2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1wt__huff.html#a325a462def35f8bc21747d3c6ea0edf2">wt_huff</a> (const <a class="el" href="classsdsl_1_1wt__huff.html">wt_huff</a> &amp;<a class="el" href="classsdsl_1_1wt.html">wt</a>)</td></tr>
<tr class="memdesc:a325a462def35f8bc21747d3c6ea0edf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr class="memitem:a30d7adfcbee127880fd8b49c008d33c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30d7adfcbee127880fd8b49c008d33c3"></a>
<a class="el" href="classsdsl_1_1wt__huff.html">wt_huff</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1wt__huff.html#a30d7adfcbee127880fd8b49c008d33c3">operator=</a> (const <a class="el" href="classsdsl_1_1wt__huff.html">wt_huff</a> &amp;<a class="el" href="classsdsl_1_1wt.html">wt</a>)</td></tr>
<tr class="memdesc:a30d7adfcbee127880fd8b49c008d33c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br/></td></tr>
<tr class="memitem:aa4e05dfd86171fbd272712c3aa2bbfcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4e05dfd86171fbd272712c3aa2bbfcb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1wt__huff.html#aa4e05dfd86171fbd272712c3aa2bbfcb">swap</a> (<a class="el" href="classsdsl_1_1wt__huff.html">wt_huff</a> &amp;<a class="el" href="classsdsl_1_1wt.html">wt</a>)</td></tr>
<tr class="memdesc:aa4e05dfd86171fbd272712c3aa2bbfcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap operator. <br/></td></tr>
<tr class="memitem:ae458886ca5901fafaffde73375ac8e32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae458886ca5901fafaffde73375ac8e32"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1wt__huff.html#ae458886ca5901fafaffde73375ac8e32">size</a> () const </td></tr>
<tr class="memdesc:ae458886ca5901fafaffde73375ac8e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the original vector. <br/></td></tr>
<tr class="memitem:ad1ec60533c702470822811e84e9b3c43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1ec60533c702470822811e84e9b3c43"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1wt__huff.html#ad1ec60533c702470822811e84e9b3c43">empty</a> () const </td></tr>
<tr class="memdesc:ad1ec60533c702470822811e84e9b3c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the wavelet tree contains no data. <br/></td></tr>
<tr class="memitem:af52026cb3546e1a699ef6c76c9966439"><td class="memItemLeft" align="right" valign="top">value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1wt__huff.html#af52026cb3546e1a699ef6c76c9966439">operator[]</a> (size_type i) const </td></tr>
<tr class="memdesc:af52026cb3546e1a699ef6c76c9966439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers the ith symbol of the original vector.  <a href="#af52026cb3546e1a699ef6c76c9966439"></a><br/></td></tr>
<tr class="memitem:a95d43deede23dfb41bb3b8a1227efd6a"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1wt__huff.html#a95d43deede23dfb41bb3b8a1227efd6a">rank</a> (size_type i, value_type c) const </td></tr>
<tr class="memdesc:a95d43deede23dfb41bb3b8a1227efd6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates how many symbols c are in the prefix [0..i-1] of the supported vector.  <a href="#a95d43deede23dfb41bb3b8a1227efd6a"></a><br/></td></tr>
<tr class="memitem:af2346cee23e87d775064d52543eb25a6"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1wt__huff.html#af2346cee23e87d775064d52543eb25a6">rank_ith_symbol</a> (size_type i, value_type &amp;c) const </td></tr>
<tr class="memdesc:af2346cee23e87d775064d52543eb25a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates how many occurrences of symbol wt[i] are in the prefix [0..i-1] of the original sequence.  <a href="#af2346cee23e87d775064d52543eb25a6"></a><br/></td></tr>
<tr class="memitem:afbd2485b588764b3e46393c6387eeeff"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1wt__huff.html#afbd2485b588764b3e46393c6387eeeff">select</a> (size_type i, value_type c) const </td></tr>
<tr class="memdesc:afbd2485b588764b3e46393c6387eeeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the ith occurrence of the symbol c in the supported vector.  <a href="#afbd2485b588764b3e46393c6387eeeff"></a><br/></td></tr>
<tr class="memitem:aa59dab4fd32b135edf2bdf0f52af8690"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1wt__huff.html#aa59dab4fd32b135edf2bdf0f52af8690">interval_symbols</a> (size_type i, size_type j, size_type &amp;k, std::vector&lt; unsigned char &gt; &amp;cs, std::vector&lt; size_type &gt; &amp;rank_c_i, std::vector&lt; size_type &gt; &amp;rank_c_j) const </td></tr>
<tr class="memdesc:aa59dab4fd32b135edf2bdf0f52af8690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates for each symbol c in wt[i..j-1], how many times c occurs in wt[0..i-1] and wt[0..j-1].  <a href="#aa59dab4fd32b135edf2bdf0f52af8690"></a><br/></td></tr>
<tr class="memitem:a71277899c11682a709ff635b5b0f43ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71277899c11682a709ff635b5b0f43ea"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1wt__huff.html#a71277899c11682a709ff635b5b0f43ea">serialize</a> (std::ostream &amp;out, <a class="el" href="classsdsl_1_1structure__tree__node.html">structure_tree_node</a> *v=NULL, std::string name=&quot;&quot;) const </td></tr>
<tr class="memdesc:a71277899c11682a709ff635b5b0f43ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the data structure into the given ostream. <br/></td></tr>
<tr class="memitem:a40a80f0efc6a099b7a6cd9945a6d1782"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40a80f0efc6a099b7a6cd9945a6d1782"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdsl_1_1wt__huff.html#a40a80f0efc6a099b7a6cd9945a6d1782">load</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:a40a80f0efc6a099b7a6cd9945a6d1782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the data structure from the given istream. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a44a3254a1c880048fb1fe781e55cff4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44a3254a1c880048fb1fe781e55cff4f"></a>
const size_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>sigma</b></td></tr>
<tr class="memitem:aac34c45e71875ba7fbf334c15dc67e83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac34c45e71875ba7fbf334c15dc67e83"></a>
const bit_vector_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>tree</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class BitVector = bit_vector, class RankSupport = typename BitVector::rank_1_type, class SelectSupport = typename BitVector::select_1_type, class SelectSupportZero = typename BitVector::select_0_type, bool dfs_shape = 0&gt;<br/>
class sdsl::wt_huff&lt; BitVector, RankSupport, SelectSupport, SelectSupportZero, dfs_shape &gt;</h3>

<p>A Wavelet Tree class for byte sequences. </p>
<p>A wavelet tree is build for a vector of characters over the alphabet <img class="formulaInl" alt="$\Sigma$" src="form_234.png"/>. This class should be used only for small alphabets <img class="formulaInl" alt="$\Sigma \ll n$" src="form_252.png"/> (see int_wavelet_tree for a wavelet tree for big alphabets). The wavelet tree <img class="formulaInl" alt="$wt$" src="form_236.png"/> consists of a tree of bitvectors and provides three efficient methods:</p>
<ul>
<li>The "[]"-operator: <img class="formulaInl" alt="$wt[i]$" src="form_237.png"/> returns the ith symbol of vector for which the wavelet tree was build for.</li>
<li>The rank method: <img class="formulaInl" alt="$wt.rank(i,c)$" src="form_238.png"/> returns the number of occurences of symbol <img class="formulaInl" alt="$c$" src="form_239.png"/> in the prefix [0..i-1] in the vector for which the wavelet tree was build for.</li>
<li>The select method: <img class="formulaInl" alt="$wt.select(j,c)$" src="form_240.png"/> returns the index <img class="formulaInl" alt="$i\in [0..size()-1]$" src="form_105.png"/> of the jth occurence of symbol <img class="formulaInl" alt="$c$" src="form_239.png"/>.</li>
</ul>
<p>The idea of using a Huffman shaped wavelet was first mentioned on page 17 of the following technical report: Veli Mäkinen and Gonzalo Navarro: Succinct Suffix Arrays based on Run-Length Encoding. Available under: <a href="http://swp.dcc.uchile.cl/TR/2005/TR_DCC-2005-004.pdf">http://swp.dcc.uchile.cl/TR/2005/TR_DCC-2005-004.pdf</a> </p>
<div class="fragment"><pre class="fragment">  \par Space complexity
</pre></div><p> <img class="formulaInl" alt="$\Order{n H_0 + 2|\Sigma|\log n}$" src="form_253.png"/> bits, where <img class="formulaInl" alt="$n$" src="form_20.png"/> is the size of the vector the wavelet tree was build for. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a788cf767698999e8619b51640dff93fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitVector = bit_vector, class RankSupport = typename BitVector::rank_1_type, class SelectSupport = typename BitVector::select_1_type, class SelectSupportZero = typename BitVector::select_0_type, bool dfs_shape = 0&gt; </div>
<div class="memtemplate">
template&lt;typename RandomAccessContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsdsl_1_1wt__huff.html">sdsl::wt_huff</a>&lt; BitVector, RankSupport, SelectSupport, SelectSupportZero, dfs_shape &gt;::<a class="el" href="classsdsl_1_1wt__huff.html">wt_huff</a> </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessContainer &amp;&#160;</td>
          <td class="paramname"><em>rac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<div class="fragment"><pre class="fragment">   \param rac Reference to the vector (or unsigned char array) for which the wavelet tree should be build.
   \param size Size of the prefix of the vector (or unsigned char array) for which the wavelet tree should be build.
   \par Time complexity
</pre></div><p> <img class="formulaInl" alt="$ \Order{n\log|\Sigma|}$" src="form_242.png"/>, where <img class="formulaInl" alt="$n=size$" src="form_243.png"/> </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a19819fd81f6f6e4f0bfaf2129f5c50e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitVector = bit_vector, class RankSupport = typename BitVector::rank_1_type, class SelectSupport = typename BitVector::select_1_type, class SelectSupportZero = typename BitVector::select_0_type, bool dfs_shape = 0&gt; </div>
<div class="memtemplate">
template&lt;class size_type_class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsdsl_1_1wt__huff.html">sdsl::wt_huff</a>&lt; BitVector, RankSupport, SelectSupport, SelectSupportZero, dfs_shape &gt;::construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsdsl_1_1int__vector__file__buffer.html">int_vector_file_buffer</a>&lt; 8, size_type_class &gt; &amp;&#160;</td>
          <td class="paramname"><em>rac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct the wavelet tree from a random access container. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rac</td><td>A random access container </td></tr>
    <tr><td class="paramname">size</td><td>The length of the prefix of the random access container, for which the wavelet tree should be build </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa59dab4fd32b135edf2bdf0f52af8690"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitVector = bit_vector, class RankSupport = typename BitVector::rank_1_type, class SelectSupport = typename BitVector::select_1_type, class SelectSupportZero = typename BitVector::select_0_type, bool dfs_shape = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsdsl_1_1wt__huff.html">sdsl::wt_huff</a>&lt; BitVector, RankSupport, SelectSupport, SelectSupportZero, dfs_shape &gt;::<a class="el" href="classsdsl_1_1wt__huff.html#aa59dab4fd32b135edf2bdf0f52af8690">interval_symbols</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rank_c_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rank_c_j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates for each symbol c in wt[i..j-1], how many times c occurs in wt[0..i-1] and wt[0..j-1]. </p>
<div class="fragment"><pre class="fragment">   \param i The start index (inclusive) of the interval.
   \param j The end index (exclusive) of the interval.
   \param k Reference that will contain the number of different symbols in wt[i..j-1].
</pre></div> <dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cs</td><td>Reference to a vector of size k that will contain all symbols that occur in wt[i..j-1] in arbitrary order. </td></tr>
    <tr><td class="paramname">rank_c_i</td><td>Reference to a vector which equals rank_c_i[p] = rank(i,cs[p]), for <img class="formulaInl" alt="$ 0 \leq p < k $" src="form_246.png"/> </td></tr>
    <tr><td class="paramname">rank_c_j</td><td>Reference to a vector which equals rank_c_j[p] = rank(j,cs[p]), for <img class="formulaInl" alt="$ 0 \leq p < k $" src="form_246.png"/> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</b></dt><dd><img class="formulaInl" alt="$ \Order{\min{\sigma, k \log \sigma}} $" src="form_247.png"/></dd></dl>
<dl class="section user"><dt>Precondition</b></dt><dd><img class="formulaInl" alt="$ i\leq j $" src="form_248.png"/> <img class="formulaInl" alt="$ cs.size() \geq \sigma $" src="form_249.png"/> <img class="formulaInl" alt="$ rank_c_i.size() \geq \sigma $" src="form_250.png"/> <img class="formulaInl" alt="$ rank_c_j.size() \geq \sigma $" src="form_251.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="af52026cb3546e1a699ef6c76c9966439"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitVector = bit_vector, class RankSupport = typename BitVector::rank_1_type, class SelectSupport = typename BitVector::select_1_type, class SelectSupportZero = typename BitVector::select_0_type, bool dfs_shape = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">value_type <a class="el" href="classsdsl_1_1wt__huff.html">sdsl::wt_huff</a>&lt; BitVector, RankSupport, SelectSupport, SelectSupportZero, dfs_shape &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recovers the ith symbol of the original vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the symbol in the original vector. <img class="formulaInl" alt="$i \in [0..size()-1]$" src="form_244.png"/> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The ith symbol of the original vector. </dd></dl>
<dl class="section user"><dt>Time complexity</b></dt><dd><img class="formulaInl" alt="$ \Order{H_0} $" src="form_254.png"/> on average, where <img class="formulaInl" alt="$ H_0 $" src="form_255.png"/> is the zero order entropy of the sequence. </dd></dl>

</div>
</div>
<a class="anchor" id="a95d43deede23dfb41bb3b8a1227efd6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitVector = bit_vector, class RankSupport = typename BitVector::rank_1_type, class SelectSupport = typename BitVector::select_1_type, class SelectSupportZero = typename BitVector::select_0_type, bool dfs_shape = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classsdsl_1_1wt__huff.html">sdsl::wt_huff</a>&lt; BitVector, RankSupport, SelectSupport, SelectSupportZero, dfs_shape &gt;::<a class="el" href="classsdsl_1_1wt__huff.html#a95d43deede23dfb41bb3b8a1227efd6a">rank</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates how many symbols c are in the prefix [0..i-1] of the supported vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The exclusive index of the prefix range [0..i-1], so <img class="formulaInl" alt="$i\in[0..size()]$" src="form_245.png"/>. </td></tr>
    <tr><td class="paramname">c</td><td>The symbol to count the occurrences in the prefix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The number of occurrences of symbol c in the prefix [0..i-1] of the supported vector. </dd></dl>
<dl class="section user"><dt>Time complexity</b></dt><dd><img class="formulaInl" alt="$ \Order{H_0} $" src="form_254.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="af2346cee23e87d775064d52543eb25a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitVector = bit_vector, class RankSupport = typename BitVector::rank_1_type, class SelectSupport = typename BitVector::select_1_type, class SelectSupportZero = typename BitVector::select_0_type, bool dfs_shape = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classsdsl_1_1wt__huff.html">sdsl::wt_huff</a>&lt; BitVector, RankSupport, SelectSupport, SelectSupportZero, dfs_shape &gt;::<a class="el" href="classsdsl_1_1wt__huff.html#af2346cee23e87d775064d52543eb25a6">rank_ith_symbol</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates how many occurrences of symbol wt[i] are in the prefix [0..i-1] of the original sequence. </p>
<div class="fragment"><pre class="fragment">   \param i The index of the symbol.
</pre></div> <dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Reference that will contain symbol wt[i]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The number of occurrences of symbol wt[i] in the prefix [0..i-1] </dd></dl>
<dl class="section user"><dt>Time complexity</b></dt><dd><img class="formulaInl" alt="$ \Order{H_0} $" src="form_254.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="afbd2485b588764b3e46393c6387eeeff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitVector = bit_vector, class RankSupport = typename BitVector::rank_1_type, class SelectSupport = typename BitVector::select_1_type, class SelectSupportZero = typename BitVector::select_0_type, bool dfs_shape = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classsdsl_1_1wt__huff.html">sdsl::wt_huff</a>&lt; BitVector, RankSupport, SelectSupport, SelectSupportZero, dfs_shape &gt;::<a class="el" href="classsdsl_1_1wt__huff.html#afbd2485b588764b3e46393c6387eeeff">select</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the ith occurrence of the symbol c in the supported vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The ith occurrence. <img class="formulaInl" alt="$i\in [1..rank(size(),c)]$" src="form_99.png"/>. </td></tr>
    <tr><td class="paramname">c</td><td>The symbol c. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</b></dt><dd><img class="formulaInl" alt="$ \Order{H_0} $" src="form_254.png"/> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>sdsl/include/sdsl/<a class="el" href="wt__huff_8hpp_source.html">wt_huff.hpp</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 13 2012 14:05:51 for SDSL: Succinct Data Structure Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
