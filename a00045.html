<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>SDSL: Succinct Data Structure Library: sdsl::cst_sct3&lt; Csa, Lcp, Bp_support, Rank_support &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">SDSL: Succinct Data Structure Library
   
   </div>
   <div id="projectbrief">A C++ template library for succinct data structures</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00285.html">sdsl</a>      </li>
      <li class="navelem"><a class="el" href="a00045.html">cst_sct3</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">sdsl::cst_sct3&lt; Csa, Lcp, Bp_support, Rank_support &gt; Class Template Reference<div class="ingroups"><a class="el" href="a00303.html">Compressed Suffix Trees (CST)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.  
 <a href="a00045.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00213_source.html">cst_sct3.hpp</a>&gt;</code></p>

<p><a href="a00340.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aebf3a1b7a11cdea9a67e3cdf759ad23f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebf3a1b7a11cdea9a67e3cdf759ad23f"></a>
typedef Csa::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="memitem:a059722ec00e29b71028e9c91b679d670"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a059722ec00e29b71028e9c91b679d670"></a>
typedef <br class="typebreak"/>
<a class="el" href="a00041.html">cst_dfs_const_forward_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="a00045.html">cst_sct3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="memitem:a86ce2d0793a81e88da4ba57f832a7595"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86ce2d0793a81e88da4ba57f832a7595"></a>
typedef <br class="typebreak"/>
<a class="el" href="a00040.html">cst_bottom_up_const_forward_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="a00045.html">cst_sct3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_bottom_up_iterator</b></td></tr>
<tr class="memitem:a8e5fc8aab8c4b5b3658fa25198b5c505"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e5fc8aab8c4b5b3658fa25198b5c505"></a>
typedef const value_type&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="memitem:a76015fa90d15d87482bd541f8462bc8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76015fa90d15d87482bd541f8462bc8a"></a>
typedef const_reference&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="memitem:ae6984c966fdb113c91ad14f0830a4b2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6984c966fdb113c91ad14f0830a4b2c"></a>
typedef const_reference *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="memitem:a79b4eeaacb2384480706d9f8e9a8603d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79b4eeaacb2384480706d9f8e9a8603d"></a>
typedef const pointer&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="memitem:ad5f12d4b5e5659c428bf7bf11380373c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5f12d4b5e5659c428bf7bf11380373c"></a>
typedef Csa::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="memitem:affc3b3375350ef928c675f81fbbc1664"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affc3b3375350ef928c675f81fbbc1664"></a>
typedef size_type&#160;</td><td class="memItemRight" valign="bottom"><b>cst_size_type</b></td></tr>
<tr class="memitem:abb8048419ff2c8dba6f75fabd4b48ca9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb8048419ff2c8dba6f75fabd4b48ca9"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="memitem:a7b73baefa920d11f56001e14c0aee342"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b73baefa920d11f56001e14c0aee342"></a>
typedef Csa&#160;</td><td class="memItemRight" valign="bottom"><b>csa_type</b></td></tr>
<tr class="memitem:a3f48d35f2039d9162b4fbc8fd5f61575"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f48d35f2039d9162b4fbc8fd5f61575"></a>
typedef Lcp::template type<br class="typebreak"/>
&lt; <a class="el" href="a00045.html">cst_sct3</a> &gt;::lcp_type&#160;</td><td class="memItemRight" valign="bottom"><b>lcp_type</b></td></tr>
<tr class="memitem:a57d60317874d928961454b2d2533362e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57d60317874d928961454b2d2533362e"></a>
typedef Bp_support&#160;</td><td class="memItemRight" valign="bottom"><b>bp_support_type</b></td></tr>
<tr class="memitem:a753fe357be61f97ab5100fd23f68cc35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a753fe357be61f97ab5100fd23f68cc35"></a>
typedef Csa::pattern_type&#160;</td><td class="memItemRight" valign="bottom"><b>pattern_type</b></td></tr>
<tr class="memitem:a99fd1bc0780abbd98ec17f95b8d20c81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99fd1bc0780abbd98ec17f95b8d20c81"></a>
typedef Csa::char_type&#160;</td><td class="memItemRight" valign="bottom"><b>char_type</b></td></tr>
<tr class="memitem:acf5d23358425c7198b5e565b517456e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf5d23358425c7198b5e565b517456e9"></a>
typedef <a class="el" href="a00017.html">bp_interval</a>&lt; size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a></td></tr>
<tr class="memdesc:acf5d23358425c7198b5e565b517456e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for the nodes in the tree. <br/></td></tr>
<tr class="memitem:a4817e037769ac025ca2891d8883e18f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4817e037769ac025ca2891d8883e18f3"></a>
typedef Rank_support&#160;</td><td class="memItemRight" valign="bottom"><b>fc_rank_support_type</b></td></tr>
<tr class="memitem:af8003fbf068f4ffe6ff8363346a6086d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8003fbf068f4ffe6ff8363346a6086d"></a>
typedef <a class="el" href="a00047.html">cst_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><b>index_category</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:gab89dec2e2366ebc6b8d7c23354c7f5ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab89dec2e2366ebc6b8d7c23354c7f5ad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00297.html#gab89dec2e2366ebc6b8d7c23354c7f5ad">cst_sct3</a> ()</td></tr>
<tr class="memdesc:gab89dec2e2366ebc6b8d7c23354c7f5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor. <br/></td></tr>
<tr class="memitem:ga5bc0360607daaf765b0293a4bc2fd870"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5bc0360607daaf765b0293a4bc2fd870"></a>
template&lt;uint8_t int_width, class size_type_class , uint8_t int_width_1, class size_type_class_1 , uint8_t int_width_2, class size_type_class_2 &gt; </td></tr>
<tr class="memitem:ga5bc0360607daaf765b0293a4bc2fd870"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cst_sct3</b> (const std::string &amp;cst_file_name, <a class="el" href="a00070.html">int_vector_file_buffer</a>&lt; int_width, size_type_class &gt; &amp;lcp_buf, <a class="el" href="a00070.html">int_vector_file_buffer</a>&lt; int_width_1, size_type_class_1 &gt; &amp;sa_buf, <a class="el" href="a00070.html">int_vector_file_buffer</a>&lt; int_width_2, size_type_class_2 &gt; &amp;isa_buf, std::string dir=&quot;./&quot;, bool build_ony_bps=false)</td></tr>
<tr class="memitem:ga1638d292426c6479b9b97282e58316c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1638d292426c6479b9b97282e58316c9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>cst_sct3</b> (tMSS &amp;file_map, const std::string &amp;dir, const std::string &amp;<a class="el" href="a00298.html#gab368bf6371b8be6de329112079131a61">id</a>, bool build_only_bps=false)</td></tr>
<tr class="memitem:gaf6be0ba2e2a0ee1dc1301181a3df518c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00297.html#gaf6be0ba2e2a0ee1dc1301181a3df518c">cst_sct3</a> (const <a class="el" href="a00045.html">cst_sct3</a> &amp;cst)</td></tr>
<tr class="memdesc:gaf6be0ba2e2a0ee1dc1301181a3df518c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="a00297.html#gaf6be0ba2e2a0ee1dc1301181a3df518c"></a><br/></td></tr>
<tr class="memitem:a7fbe4f5eaec1f267ac59427587e093d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fbe4f5eaec1f267ac59427587e093d1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a7fbe4f5eaec1f267ac59427587e093d1">~cst_sct3</a> ()</td></tr>
<tr class="memdesc:a7fbe4f5eaec1f267ac59427587e093d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Destructor. <br/></td></tr>
<tr class="memitem:a8ff5c46b3271936d2e3e1d039aa310d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ff5c46b3271936d2e3e1d039aa310d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>construct</b> (tMSS &amp;file_map, const std::string &amp;dir, const std::string &amp;<a class="el" href="a00298.html#gab368bf6371b8be6de329112079131a61">id</a>, bool build_only_bps=false)</td></tr>
<tr class="memitem:a1ebc92789be36da7dc8fdfcd0f786518"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a1ebc92789be36da7dc8fdfcd0f786518">size</a> () const </td></tr>
<tr class="memdesc:a1ebc92789be36da7dc8fdfcd0f786518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of leaves of the suffix tree.  <a href="#a1ebc92789be36da7dc8fdfcd0f786518"></a><br/></td></tr>
<tr class="memitem:aaa222cd2cd93cb222e5c88c2dbb1cc83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#aaa222cd2cd93cb222e5c88c2dbb1cc83">empty</a> () const </td></tr>
<tr class="memdesc:aaa222cd2cd93cb222e5c88c2dbb1cc83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the data strucutre is empty.  <a href="#aaa222cd2cd93cb222e5c88c2dbb1cc83"></a><br/></td></tr>
<tr class="memitem:adae6ec1ca2777237d2a767a81ea41e89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#adae6ec1ca2777237d2a767a81ea41e89">swap</a> (<a class="el" href="a00045.html">cst_sct3</a> &amp;cst)</td></tr>
<tr class="memdesc:adae6ec1ca2777237d2a767a81ea41e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap method for <a class="el" href="a00045.html" title="A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.">cst_sct3</a>.  <a href="#adae6ec1ca2777237d2a767a81ea41e89"></a><br/></td></tr>
<tr class="memitem:af296bd8cca2e80c1d644fd88095bf912"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00041.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#af296bd8cca2e80c1d644fd88095bf912">begin</a> () const </td></tr>
<tr class="memdesc:af296bd8cca2e80c1d644fd88095bf912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator to the first element of a depth first traversal of the tree.  <a href="#af296bd8cca2e80c1d644fd88095bf912"></a><br/></td></tr>
<tr class="memitem:a3ae6ba92a39308fe9d7d8b9c1f6e1210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00041.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a3ae6ba92a39308fe9d7d8b9c1f6e1210">end</a> () const </td></tr>
<tr class="memdesc:a3ae6ba92a39308fe9d7d8b9c1f6e1210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator to the element after the last element of a depth first traversal of the tree.  <a href="#a3ae6ba92a39308fe9d7d8b9c1f6e1210"></a><br/></td></tr>
<tr class="memitem:af15c205114617f7f1cee35bcce4e02ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af15c205114617f7f1cee35bcce4e02ec"></a>
<a class="el" href="a00040.html">const_bottom_up_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#af15c205114617f7f1cee35bcce4e02ec">begin_bottom_up</a> () const </td></tr>
<tr class="memdesc:af15c205114617f7f1cee35bcce4e02ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of a bottom-up traversal of the tree. <br/></td></tr>
<tr class="memitem:a97c03d32ae031196ad41abd171eac737"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97c03d32ae031196ad41abd171eac737"></a>
<a class="el" href="a00040.html">const_bottom_up_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a97c03d32ae031196ad41abd171eac737">end_bottom_up</a> () const </td></tr>
<tr class="memdesc:a97c03d32ae031196ad41abd171eac737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element after the last element of a bottom-up traversal of the tree. <br/></td></tr>
<tr class="memitem:a83fd8a573004f884f935c53db5dd2e86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00045.html">cst_sct3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a83fd8a573004f884f935c53db5dd2e86">operator=</a> (const <a class="el" href="a00045.html">cst_sct3</a> &amp;cst)</td></tr>
<tr class="memdesc:a83fd8a573004f884f935c53db5dd2e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment Operator.  <a href="#a83fd8a573004f884f935c53db5dd2e86"></a><br/></td></tr>
<tr class="memitem:aeea061e2dc0973d940f22fdba5757c0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#aeea061e2dc0973d940f22fdba5757c0a">operator==</a> (const <a class="el" href="a00045.html">cst_sct3</a> &amp;cst) const </td></tr>
<tr class="memdesc:aeea061e2dc0973d940f22fdba5757c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality Operator.  <a href="#aeea061e2dc0973d940f22fdba5757c0a"></a><br/></td></tr>
<tr class="memitem:ae000d5bdd58dcf081bd7ac7405e57b7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#ae000d5bdd58dcf081bd7ac7405e57b7d">operator!=</a> (const <a class="el" href="a00045.html">cst_sct3</a> &amp;cst) const </td></tr>
<tr class="memdesc:ae000d5bdd58dcf081bd7ac7405e57b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unequality Operator.  <a href="#ae000d5bdd58dcf081bd7ac7405e57b7d"></a><br/></td></tr>
<tr class="memitem:a8add5b7ca0bf7f79b63205f747c763f1"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a8add5b7ca0bf7f79b63205f747c763f1">serialize</a> (std::ostream &amp;out, <a class="el" href="a00157.html">structure_tree_node</a> *v=NULL, std::string name=&quot;&quot;) const </td></tr>
<tr class="memdesc:a8add5b7ca0bf7f79b63205f747c763f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize to a stream.  <a href="#a8add5b7ca0bf7f79b63205f747c763f1"></a><br/></td></tr>
<tr class="memitem:abc04ebee93099b8c82410ce55851f982"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#abc04ebee93099b8c82410ce55851f982">load</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:abc04ebee93099b8c82410ce55851f982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load from a stream.  <a href="#abc04ebee93099b8c82410ce55851f982"></a><br/></td></tr>
<tr class="memitem:gaeee744147cdc9093af5877eb0a2352e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#gaeee744147cdc9093af5877eb0a2352e8">root</a> () const </td></tr>
<tr class="memdesc:gaeee744147cdc9093af5877eb0a2352e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the root of the suffix tree.  <a href="a00298.html#gaeee744147cdc9093af5877eb0a2352e8"></a><br/></td></tr>
<tr class="memitem:gac3f5ef33aebbda796d2466f59fef6fe3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#gac3f5ef33aebbda796d2466f59fef6fe3">is_leaf</a> (const <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:gac3f5ef33aebbda796d2466f59fef6fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide if a node is a leaf in the suffix tree.  <a href="a00298.html#gac3f5ef33aebbda796d2466f59fef6fe3"></a><br/></td></tr>
<tr class="memitem:ga39276fbb2f2ca1a215988041e2cfa5e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#ga39276fbb2f2ca1a215988041e2cfa5e8">ith_leaf</a> (size_type i) const </td></tr>
<tr class="memdesc:ga39276fbb2f2ca1a215988041e2cfa5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i-th leaf (1-based from left to right) of the suffix tree.  <a href="a00298.html#ga39276fbb2f2ca1a215988041e2cfa5e8"></a><br/></td></tr>
<tr class="memitem:ga1c13f047bcaff5c51c74b0260adec00b"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#ga1c13f047bcaff5c51c74b0260adec00b">leaves_in_the_subtree</a> (const <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:ga1c13f047bcaff5c51c74b0260adec00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the number of leaves in the subtree rooted at node v.  <a href="a00298.html#ga1c13f047bcaff5c51c74b0260adec00b"></a><br/></td></tr>
<tr class="memitem:ga8b2b51413be3ffc3dd37a40b57416de8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#ga8b2b51413be3ffc3dd37a40b57416de8">leftmost_leaf_in_the_subtree</a> (const <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:ga8b2b51413be3ffc3dd37a40b57416de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the leftmost leaf in the subtree rooted at node v.  <a href="a00298.html#ga8b2b51413be3ffc3dd37a40b57416de8"></a><br/></td></tr>
<tr class="memitem:ga85e04c5b0f72358298137ac0601f6c8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#ga85e04c5b0f72358298137ac0601f6c8c">rightmost_leaf_in_the_subtree</a> (const <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:ga85e04c5b0f72358298137ac0601f6c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rightmost leaf in the subtree rooted at node v.  <a href="a00298.html#ga85e04c5b0f72358298137ac0601f6c8c"></a><br/></td></tr>
<tr class="memitem:ga613b578c45340b7088842b89ca43ff2b"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#ga613b578c45340b7088842b89ca43ff2b">lb</a> (const <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:ga613b578c45340b7088842b89ca43ff2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the index of the leftmost leaf in the corresponding suffix array.  <a href="a00298.html#ga613b578c45340b7088842b89ca43ff2b"></a><br/></td></tr>
<tr class="memitem:ga48c27c72f9eef7e32ef221299db7b0d3"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#ga48c27c72f9eef7e32ef221299db7b0d3">rb</a> (const <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:ga48c27c72f9eef7e32ef221299db7b0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the index of the rightmost leaf in the corresponding suffix array.  <a href="a00298.html#ga48c27c72f9eef7e32ef221299db7b0d3"></a><br/></td></tr>
<tr class="memitem:gaee743656fa0f13f8affcdc872db85c9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#gaee743656fa0f13f8affcdc872db85c9f">parent</a> (const <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:gaee743656fa0f13f8affcdc872db85c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the parent node of a node v.  <a href="a00298.html#gaee743656fa0f13f8affcdc872db85c9f"></a><br/></td></tr>
<tr class="memitem:gacb5b379c50085f00cd345507d2bfd786"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#gacb5b379c50085f00cd345507d2bfd786">sibling</a> (const <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:gacb5b379c50085f00cd345507d2bfd786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next sibling of node v.  <a href="a00298.html#gacb5b379c50085f00cd345507d2bfd786"></a><br/></td></tr>
<tr class="memitem:ga321d8a8f5a771c88744588493419d81b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#ga321d8a8f5a771c88744588493419d81b">ith_child</a> (const <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> &amp;v, size_type i) const </td></tr>
<tr class="memdesc:ga321d8a8f5a771c88744588493419d81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ith child of a node v.  <a href="a00298.html#ga321d8a8f5a771c88744588493419d81b"></a><br/></td></tr>
<tr class="memitem:ga8e97ba35e77ac43ae1d243dbd0fbe707"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#ga8e97ba35e77ac43ae1d243dbd0fbe707">degree</a> (const <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:ga8e97ba35e77ac43ae1d243dbd0fbe707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of children of a node v.  <a href="a00298.html#ga8e97ba35e77ac43ae1d243dbd0fbe707"></a><br/></td></tr>
<tr class="memitem:ga4b137f65378465b65c4a885765af9b65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4b137f65378465b65c4a885765af9b65"></a>
<a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sibling_naive</b> (const <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> &amp;v) const </td></tr>
<tr class="memitem:gac47bd664dd164685ff2455c891291c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#gac47bd664dd164685ff2455c891291c4b">child</a> (const <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> &amp;v, const unsigned char c, size_type &amp;char_pos) const </td></tr>
<tr class="memdesc:gac47bd664dd164685ff2455c891291c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the child w of node v which edge label (v,w) starts with character c.  <a href="a00298.html#gac47bd664dd164685ff2455c891291c4b"></a><br/></td></tr>
<tr class="memitem:ga03787a3e79ec028e5ee99f1d746e6a35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga03787a3e79ec028e5ee99f1d746e6a35"></a>
<a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#ga03787a3e79ec028e5ee99f1d746e6a35">child</a> (const <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> &amp;v, const unsigned char c)</td></tr>
<tr class="memdesc:ga03787a3e79ec028e5ee99f1d746e6a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the child w of node v which edge label (v,w) starts with character c. <br/></td></tr>
<tr class="memitem:gaa9d16a2e5be4617daeef2810f897f6a7"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#gaa9d16a2e5be4617daeef2810f897f6a7">edge</a> (const <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> &amp;v, size_type d) const </td></tr>
<tr class="memdesc:gaa9d16a2e5be4617daeef2810f897f6a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the d-th character (1-based indexing) of the edge-label pointing to v.  <a href="a00298.html#gaa9d16a2e5be4617daeef2810f897f6a7"></a><br/></td></tr>
<tr class="memitem:ga6bde45c0d11eec11f5a45bcee19934e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#ga6bde45c0d11eec11f5a45bcee19934e7">lca</a> (<a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> v, <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> w) const </td></tr>
<tr class="memdesc:ga6bde45c0d11eec11f5a45bcee19934e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the lowest common ancestor (lca) of two nodes v and w of the suffix tree.  <a href="a00298.html#ga6bde45c0d11eec11f5a45bcee19934e7"></a><br/></td></tr>
<tr class="memitem:gab6978af345ea4864b97b56e638a42a4a"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#gab6978af345ea4864b97b56e638a42a4a">depth</a> (const <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:gab6978af345ea4864b97b56e638a42a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string depth of node v.  <a href="a00298.html#gab6978af345ea4864b97b56e638a42a4a"></a><br/></td></tr>
<tr class="memitem:gaadfaf961d9413c576f357733a3dd298a"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#gaadfaf961d9413c576f357733a3dd298a">node_depth</a> (<a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> v) const </td></tr>
<tr class="memdesc:gaadfaf961d9413c576f357733a3dd298a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node depth of node v.  <a href="a00298.html#gaadfaf961d9413c576f357733a3dd298a"></a><br/></td></tr>
<tr class="memitem:ga08715fd9de5cb9ef1cfd70fb7c4f7977"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#ga08715fd9de5cb9ef1cfd70fb7c4f7977">sl</a> (const <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:ga08715fd9de5cb9ef1cfd70fb7c4f7977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the suffix link of node v.  <a href="a00298.html#ga08715fd9de5cb9ef1cfd70fb7c4f7977"></a><br/></td></tr>
<tr class="memitem:ga7f1f675dfb95a1656fbfccc61694a039"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7f1f675dfb95a1656fbfccc61694a039"></a>
<a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#ga7f1f675dfb95a1656fbfccc61694a039">wl</a> (const <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> &amp;v, const unsigned char c) const </td></tr>
<tr class="memdesc:ga7f1f675dfb95a1656fbfccc61694a039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Weiner link of node v and character c. <br/></td></tr>
<tr class="memitem:gaec49ce93e5adecfc6fc94d88be98af22"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#gaec49ce93e5adecfc6fc94d88be98af22">sn</a> (const <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:gaec49ce93e5adecfc6fc94d88be98af22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the suffix number of a leaf node v.  <a href="a00298.html#gaec49ce93e5adecfc6fc94d88be98af22"></a><br/></td></tr>
<tr class="memitem:gab368bf6371b8be6de329112079131a61"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#gab368bf6371b8be6de329112079131a61">id</a> (const <a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a> &amp;v) const </td></tr>
<tr class="memdesc:gab368bf6371b8be6de329112079131a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a unique identification number for a node of the suffx tree in the range [0..<a class="el" href="a00298.html#gaf95d047f4e8717e94fef5295cdee16b2" title="Get the number of nodes of the suffix tree.">nodes()</a>-1].  <a href="a00298.html#gab368bf6371b8be6de329112079131a61"></a><br/></td></tr>
<tr class="memitem:ga8c510b8298793533fe997bc7d5fedc64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#ga8c510b8298793533fe997bc7d5fedc64">inv_id</a> (size_type <a class="el" href="a00298.html#gab368bf6371b8be6de329112079131a61">id</a>)</td></tr>
<tr class="memdesc:ga8c510b8298793533fe997bc7d5fedc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the node for such that id(v)=id.  <a href="a00298.html#ga8c510b8298793533fe997bc7d5fedc64"></a><br/></td></tr>
<tr class="memitem:gaf95d047f4e8717e94fef5295cdee16b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf95d047f4e8717e94fef5295cdee16b2"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#gaf95d047f4e8717e94fef5295cdee16b2">nodes</a> () const </td></tr>
<tr class="memdesc:gaf95d047f4e8717e94fef5295cdee16b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of nodes of the suffix tree. <br/></td></tr>
<tr class="memitem:gaefa2c147fe29fbab270d982d67177990"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaefa2c147fe29fbab270d982d67177990"></a>
<a class="el" href="a00045.html#acf5d23358425c7198b5e565b517456e9">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#gaefa2c147fe29fbab270d982d67177990">node</a> (size_type <a class="el" href="a00298.html#ga613b578c45340b7088842b89ca43ff2b">lb</a>, size_type <a class="el" href="a00298.html#ga48c27c72f9eef7e32ef221299db7b0d3">rb</a>, size_type l=0) const </td></tr>
<tr class="memdesc:gaefa2c147fe29fbab270d982d67177990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node in the suffix tree which corresponds to the lcp-interval [lb..rb]. <br/></td></tr>
<tr class="memitem:ga97251b1053f5387a05bdab526f374e85"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html#ga97251b1053f5387a05bdab526f374e85">tlcp_idx</a> (size_type i) const </td></tr>
<tr class="memdesc:ga97251b1053f5387a05bdab526f374e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps an index i to the position in TLCP where LCP[i] can be found.  <a href="a00298.html#ga97251b1053f5387a05bdab526f374e85"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aef3832a26ffab10f58e3d2bf7ed7e21a"><td class="memItemLeft" align="right" valign="top">static size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#aef3832a26ffab10f58e3d2bf7ed7e21a">max_size</a> ()</td></tr>
<tr class="memdesc:aef3832a26ffab10f58e3d2bf7ed7e21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest size that <a class="el" href="a00045.html" title="A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.">cst_sct3</a> can ever have.  <a href="#aef3832a26ffab10f58e3d2bf7ed7e21a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:afa8e2cd3d4b038bfed57d6f637936ab4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa8e2cd3d4b038bfed57d6f637936ab4"></a>
const Csa &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#afa8e2cd3d4b038bfed57d6f637936ab4">csa</a></td></tr>
<tr class="memdesc:afa8e2cd3d4b038bfed57d6f637936ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The compressed suffix array the suffix tree is based on. <br/></td></tr>
<tr class="memitem:ab85dac24f2dd023fa18ba802ceb3c19a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab85dac24f2dd023fa18ba802ceb3c19a"></a>
const lcp_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#ab85dac24f2dd023fa18ba802ceb3c19a">lcp</a></td></tr>
<tr class="memdesc:ab85dac24f2dd023fa18ba802ceb3c19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lcp array the suffix tree is based on. <br/></td></tr>
<tr class="memitem:a930e270fdb5d857a3335872fa0c94ec5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a930e270fdb5d857a3335872fa0c94ec5"></a>
const <a class="el" href="a00285.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a930e270fdb5d857a3335872fa0c94ec5">bp</a></td></tr>
<tr class="memdesc:a930e270fdb5d857a3335872fa0c94ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The balanced parentheses sequence of the Super-Cartesian tree the suffix tree is based on. <br/></td></tr>
<tr class="memitem:aa9384e34d14efbdce32bc27ddd143d7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9384e34d14efbdce32bc27ddd143d7b"></a>
const bp_support_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#aa9384e34d14efbdce32bc27ddd143d7b">bp_support</a></td></tr>
<tr class="memdesc:aa9384e34d14efbdce32bc27ddd143d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The balanced parentheses sequence support for member bp. <br/></td></tr>
<tr class="memitem:a3deaefd06fa943d7a4a7818059f423dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3deaefd06fa943d7a4a7818059f423dd"></a>
const <a class="el" href="a00285.html#a93df8f263fced9ae9a8b0f9f37e444eb">bit_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>first_child_bv</b></td></tr>
<tr class="memitem:abbe830e39c0396d6d93809c44f47b2fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbe830e39c0396d6d93809c44f47b2fa"></a>
const fc_rank_support_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>first_child_rank</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Csa = csa_wt&lt;&gt;, class Lcp = lcp_support_tree&lt;lcp_wt&lt;&gt; &gt;, class Bp_support = bp_support_sada&lt;&gt;, class Rank_support = rank_support_v5&lt;&gt;&gt;<br/>
class sdsl::cst_sct3&lt; Csa, Lcp, Bp_support, Rank_support &gt;</h3>

<p>A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog. </p>
<p>The CST is parameterized by</p>
<ul>
<li>a (compressed) suffix array (accessible via member <img class="formulaInl" alt="$csa$" src="form_109.png"/>, default clas is <a class="el" href="a00035.html" title="A class for the Compressed Suffix Array (CSA) based on a Wavelet Tree (WT) of the Burrow Wheeler Tran...">sdsl::csa_wt</a>),</li>
<li>a (compressed) longest common prefix array data structure (accessible via member <img class="formulaInl" alt="$lcp$" src="form_110.png"/>, default class is <a class="el" href="a00094.html" title="Helper class which provides _lcp_support_tree the context of a CST.">sdsl::lcp_support_tree</a>), and</li>
<li>a support data structure for balanced parentheses sequences (accessible via member <img class="formulaInl" alt="$bp\_support$" src="form_111.png"/>, default class is <a class="el" href="a00022.html" title="A class that provides support for bit_vectors that represent a balanced parentheses sequence...">sdsl::bp_support_sada</a>).</li>
<li>a rank support data structure for the bitvector which indicates the first child property</li>
</ul>
<p>It also contains a <a class="el" href="a00285.html#a93df8f263fced9ae9a8b0f9f37e444eb" title="bit_vector is a specialization of the int_vector.">sdsl::bit_vector</a> which represents the balanced parentheses sequence of the Super-Cartesian tree of the lcp array. This bit_vector can be accessed via the member <img class="formulaInl" alt="$bp$" src="form_112.png"/>. Another <a class="el" href="a00285.html#a93df8f263fced9ae9a8b0f9f37e444eb" title="bit_vector is a specialization of the int_vector.">sdsl::bit_vector</a> stores information, if a node is a first child of another node. This bit_vector can be access via the member first_child_bv and takes <img class="formulaInl" alt="$n$" src="form_20.png"/> bits.</p>
<p>A node <img class="formulaInl" alt="$v$" src="form_46.png"/> of the csa_sct is represented by an <a class="el" href="a00017.html">sdsl::bp_interval</a> . The size of the <a class="el" href="a00045.html" title="A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.">sdsl::cst_sct3</a> is smaller than the size of a <a class="el" href="a00042.html" title="A class for the Compressed Suffix Tree (CST) proposed by Sadakane.">sdsl::cst_sada</a> since the tree topology needs only <img class="formulaInl" alt="$2n+n=3n$" src="form_113.png"/> bits in contrast to the <img class="formulaInl" alt="$4n$" src="form_114.png"/> bits in <a class="el" href="a00042.html" title="A class for the Compressed Suffix Tree (CST) proposed by Sadakane.">sdsl::cst_sada</a>.</p>
<p>Applications of the CST: The compressed suffix tree could be used for string matching and many other application in sequence analysis. 17 applications are in the book "Algorithms on Strings, Trees, and Sequences" of Dan Gusfield. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af296bd8cca2e80c1d644fd88095bf912"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa = csa_wt&lt;&gt;, class Lcp = lcp_support_tree&lt;lcp_wt&lt;&gt; &gt;, class Bp_support = bp_support_sada&lt;&gt;, class Rank_support = rank_support_v5&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00041.html">const_iterator</a> <a class="el" href="a00045.html">sdsl::cst_sct3</a>&lt; Csa, Lcp, Bp_support, Rank_support &gt;::<a class="el" href="a00045.html#af296bd8cca2e80c1d644fd88095bf912">begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a const_iterator to the first element of a depth first traversal of the tree. </p>
<p>Required for the STL Container Concept. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="a00045.html#a3ae6ba92a39308fe9d7d8b9c1f6e1210" title="Returns a const_iterator to the element after the last element of a depth first traversal of the tree...">end</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aaa222cd2cd93cb222e5c88c2dbb1cc83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa = csa_wt&lt;&gt;, class Lcp = lcp_support_tree&lt;lcp_wt&lt;&gt; &gt;, class Bp_support = bp_support_sada&lt;&gt;, class Rank_support = rank_support_v5&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00045.html">sdsl::cst_sct3</a>&lt; Csa, Lcp, Bp_support, Rank_support &gt;::<a class="el" href="a00045.html#aaa222cd2cd93cb222e5c88c2dbb1cc83">empty</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns if the data strucutre is empty. </p>
<p>Required for the Container Concept of the STL.A </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="a00045.html#a1ebc92789be36da7dc8fdfcd0f786518" title="Number of leaves of the suffix tree.">size</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3ae6ba92a39308fe9d7d8b9c1f6e1210"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa = csa_wt&lt;&gt;, class Lcp = lcp_support_tree&lt;lcp_wt&lt;&gt; &gt;, class Bp_support = bp_support_sada&lt;&gt;, class Rank_support = rank_support_v5&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00041.html">const_iterator</a> <a class="el" href="a00045.html">sdsl::cst_sct3</a>&lt; Csa, Lcp, Bp_support, Rank_support &gt;::<a class="el" href="a00045.html#a3ae6ba92a39308fe9d7d8b9c1f6e1210">end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a const_iterator to the element after the last element of a depth first traversal of the tree. </p>
<p>Required for the STL Container Concept. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="a00045.html#af296bd8cca2e80c1d644fd88095bf912" title="Returns a const_iterator to the first element of a depth first traversal of the tree.">begin</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="abc04ebee93099b8c82410ce55851f982"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa , class Lcp , class Bp_support , class Rank_support &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00045.html">sdsl::cst_sct3</a>&lt; Csa, Lcp, Bp_support, Rank_support &gt;::<a class="el" href="a00045.html#abc04ebee93099b8c82410ce55851f982">load</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load from a stream. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Inputstream to load the data structure from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef3832a26ffab10f58e3d2bf7ed7e21a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa = csa_wt&lt;&gt;, class Lcp = lcp_support_tree&lt;lcp_wt&lt;&gt; &gt;, class Bp_support = bp_support_sada&lt;&gt;, class Rank_support = rank_support_v5&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static size_type <a class="el" href="a00045.html">sdsl::cst_sct3</a>&lt; Csa, Lcp, Bp_support, Rank_support &gt;::<a class="el" href="a00045.html#aef3832a26ffab10f58e3d2bf7ed7e21a">max_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the largest size that <a class="el" href="a00045.html" title="A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.">cst_sct3</a> can ever have. </p>
<p>Required for the Container Concept of the STL. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="a00045.html#a1ebc92789be36da7dc8fdfcd0f786518" title="Number of leaves of the suffix tree.">size</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae000d5bdd58dcf081bd7ac7405e57b7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa = csa_wt&lt;&gt;, class Lcp = lcp_support_tree&lt;lcp_wt&lt;&gt; &gt;, class Bp_support = bp_support_sada&lt;&gt;, class Rank_support = rank_support_v5&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00045.html">sdsl::cst_sct3</a>&lt; Csa, Lcp, Bp_support, Rank_support &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00045.html">cst_sct3</a>&lt; Csa, Lcp, Bp_support, Rank_support &gt; &amp;&#160;</td>
          <td class="paramname"><em>cst</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unequality Operator. </p>
<p>Two Instances of <a class="el" href="a00045.html" title="A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.">cst_sct3</a> are equal if not all their members are equal. </p>
<dl class="section user"><dt>Required for the Equality Comparable Concept of the STL.</b></dt><dd></dd></dl>
<dl class="section see"><dt>See also:</dt><dd>operator== </dd></dl>

</div>
</div>
<a class="anchor" id="a83fd8a573004f884f935c53db5dd2e86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa , class Lcp , class Bp_support , class Rank_support &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00045.html">cst_sct3</a>&lt; Csa, Lcp, Bp_support, Rank_support &gt; &amp; <a class="el" href="a00045.html">sdsl::cst_sct3</a>&lt; Csa, Lcp, Bp_support, Rank_support &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00045.html">cst_sct3</a>&lt; Csa, Lcp, Bp_support, Rank_support &gt; &amp;&#160;</td>
          <td class="paramname"><em>cst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment Operator. </p>
<p>Required for the Assignable Concept of the STL. </p>

</div>
</div>
<a class="anchor" id="aeea061e2dc0973d940f22fdba5757c0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa = csa_wt&lt;&gt;, class Lcp = lcp_support_tree&lt;lcp_wt&lt;&gt; &gt;, class Bp_support = bp_support_sada&lt;&gt;, class Rank_support = rank_support_v5&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00045.html">sdsl::cst_sct3</a>&lt; Csa, Lcp, Bp_support, Rank_support &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00045.html">cst_sct3</a>&lt; Csa, Lcp, Bp_support, Rank_support &gt; &amp;&#160;</td>
          <td class="paramname"><em>cst</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equality Operator. </p>
<p>Two Instances of <a class="el" href="a00045.html" title="A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.">cst_sct3</a> are equal if all their members are equal. </p>
<dl class="section user"><dt>Required for the Equality Comparable Concept of the STL.</b></dt><dd></dd></dl>
<dl class="section see"><dt>See also:</dt><dd>operator!= </dd></dl>

</div>
</div>
<a class="anchor" id="a8add5b7ca0bf7f79b63205f747c763f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa , class Lcp , class Bp_support , class Rank_support &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00045.html">cst_sct3</a>&lt; Csa, Lcp, Bp_support, Rank_support &gt;::size_type <a class="el" href="a00045.html">sdsl::cst_sct3</a>&lt; Csa, Lcp, Bp_support, Rank_support &gt;::<a class="el" href="a00045.html#a8add5b7ca0bf7f79b63205f747c763f1">serialize</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00157.html">structure_tree_node</a> *&#160;</td>
          <td class="paramname"><em>v</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Serialize to a stream. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Outstream to write the data structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The number of written bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ebc92789be36da7dc8fdfcd0f786518"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa = csa_wt&lt;&gt;, class Lcp = lcp_support_tree&lt;lcp_wt&lt;&gt; &gt;, class Bp_support = bp_support_sada&lt;&gt;, class Rank_support = rank_support_v5&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="a00045.html">sdsl::cst_sct3</a>&lt; Csa, Lcp, Bp_support, Rank_support &gt;::<a class="el" href="a00045.html#a1ebc92789be36da7dc8fdfcd0f786518">size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of leaves of the suffix tree. </p>
<p>Required for the Container Concept of the STL. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="a00045.html#aef3832a26ffab10f58e3d2bf7ed7e21a" title="Returns the largest size that cst_sct3 can ever have.">max_size</a>, <a class="el" href="a00045.html#aaa222cd2cd93cb222e5c88c2dbb1cc83" title="Returns if the data strucutre is empty.">empty</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adae6ec1ca2777237d2a767a81ea41e89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Csa = csa_wt&lt;&gt;, class Lcp = lcp_support_tree&lt;lcp_wt&lt;&gt; &gt;, class Bp_support = bp_support_sada&lt;&gt;, class Rank_support = rank_support_v5&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00045.html">sdsl::cst_sct3</a>&lt; Csa, Lcp, Bp_support, Rank_support &gt;::<a class="el" href="a00045.html#adae6ec1ca2777237d2a767a81ea41e89">swap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00045.html">cst_sct3</a>&lt; Csa, Lcp, Bp_support, Rank_support &gt; &amp;&#160;</td>
          <td class="paramname"><em>cst</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap method for <a class="el" href="a00045.html" title="A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.">cst_sct3</a>. </p>
<p>The swap method can be defined in terms of assignment. This requires three assignments, each of which, for a container type, is linear in the container's size. In a sense, then, a.swap(b) is redundant. This implementation guaranties a run-time complexity that is constant rather than linear. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cst</td><td><a class="el" href="a00045.html" title="A class for the Compressed Suffix Tree (CST) proposed by Ohlebusch and Gog.">cst_sct3</a> to swap.</td></tr>
  </table>
  </dd>
</dl>
<p>Required for the Assignable Conecpt of the STL. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>sdsl/include/sdsl/<a class="el" href="a00213_source.html">cst_sct3.hpp</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 13 2012 15:23:28 for SDSL: Succinct Data Structure Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
